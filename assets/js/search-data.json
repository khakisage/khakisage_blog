{
  
    
        "post0": {
            "title": "클로저 함수",
            "content": "클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다. .",
            "url": "https://khakisage.github.io/khakisage_blog/%ED%81%B4%EB%A1%9C%EC%A0%80%ED%95%A8%EC%88%98/%ED%81%B4%EB%A1%9C%EC%A0%B8%ED%95%A8%EC%88%98/%EB%A0%89%EC%8B%9C%EC%BB%AC/lexical/closure/2022/10/14/%ED%81%B4%EB%A1%9C%EC%A0%80%ED%95%A8%EC%88%98.html",
            "relUrl": "/%ED%81%B4%EB%A1%9C%EC%A0%80%ED%95%A8%EC%88%98/%ED%81%B4%EB%A1%9C%EC%A0%B8%ED%95%A8%EC%88%98/%EB%A0%89%EC%8B%9C%EC%BB%AC/lexical/closure/2022/10/14/%ED%81%B4%EB%A1%9C%EC%A0%80%ED%95%A8%EC%88%98.html",
            "date": " • Oct 14, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Primitive & Reference",
            "content": "자바스크립트의 데이터는 두 종류의 타입으로 분류된다. . 원시 타입(primitive type) . 원시 타입은 변경 불가능한 즉, immutable한 값을 말하며, 한번 생성되면 읽기 전용으로 값을 변경할 수 없다. 다시말해서, 데이터의 신뢰성이 보장된다는 말이다. 원시 타입을 a 라는 변수에 할당하면, 실제값(원시값)이 저장된다. 만일 a 라는 변수를 새로운 b 라는 변수에 할당하면 b 에는 a 라는 변수에 할당된 원시값이 복사되어 저장된다. 이것을 pass by value 즉, 값에 의한 전달이라고 한다. . 변수도 불변한가? . 우선, 변수와 값은 다른 개념이다. 변수는 하나의 값을 저장하기 위해 확보된 메모리 공간을 의미하고, 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 의미한다. 즉, 불변하다는 것은 변수가 아니라 값에 대한 의미이다. 따라서, 원시 값이 불변하다는 것은 원시 값 자체를 변경할 수 없다는 말이고, 변수는 재할당을 통해 변경 아니, 엄밀하게는 교체가 가능하다. . 그렇다면 상수는? . 상수는 변수의 상대적인 개념이다. 변수의 경우 재할당을 통해서 새로운 값으로 교체가 가능하지만, 상수는 그 뜻 자체로 항상 동일한 값을 가진다. 즉, 재할당이 불가능하다는 말이다. 자바스크립트에서 상수 또한, 값을 저장하기 위한 메모리 공간이 필요하므로 일종의 변수로 취급하지만, 앞서서 말했듯이 상수는 단 한번의 할당만 허용되기 때문에 변수의 값을 교체할 수 없다. . 객체 타입(object/reference type) . 원시 타입이 변경이 불가능한 타입이라고 했으니 자연스럽게 객체 타입은 변경이 가능하다. 객체 타입의 경우 a 라는 변수에 객체 타입을 할당 시, a에는 참조 값이 저장된다. 참조라는 것은 흔히, 논문이나 기사를 볼때, 참고하여 작성하였다는 말이다. 즉, 참조 값이란 참조 값을 저장하기 위해 확보된 메모리 공간의 주소값을 의미한다. a 라는 변수를 새로운 b 라는 변수에 할당한다면, b라는 변수에는 원본 즉, a 에 할당된 참조 값이 복사되어 저장된다. 이를 참조에 의한 전달이라고 한다. 이때, a 와 b라는 식별자는 하나의 객체를 공유한다. . a 와 b라는 식별자는 하나의 객체를 공유한다? . 예를 들어서, 그럴 일은 없겠지만 만일, 올해에 가장 인기있는 프론트 엔드 언어에 대한 보고서(b)를 써야하는 상황을 가정해보자. 그렇다면, 당신은 정확한 정보 전달을 위해 관련된 통계 자료(a)를 검색할 것이다. 그리고 해당 내용을 보고서(b)에 작성하고, 참고한 통계자료(a)를 하단의 reference 라는 항목으로 추가할 것이다. 만일 이때, (그럴일은 없겠지만) 당신이 참고한 통계자료(a)가 잘못되어서 수정이 되었다면, 당신은 보고서(b)에서 참고한 내용을 삭제 하거나 혹은 교체 하여야 한다. 이와 같이 원본의 통계 자료(a)가 변경된다면 이것을 사용한 보고서(b)의 내용도 변경해야 한다. 즉, a 와 b는 하나의 참조값을 공유한다는 의미이다. ! 다만 위의 예시는 어디까지나 좀더 이해를 돕기위함이다. 실제로는 보고서의 값을 수정한다고 통계 자료의 값이 바뀌진 않는다. .",
            "url": "https://khakisage.github.io/khakisage_blog/%EC%9B%90%EC%8B%9C/%EC%B0%B8%EC%A1%B0/%EA%B0%9D%EC%B2%B4/%EC%9E%90%EB%A3%8C%ED%98%95/2022/10/14/%EC%9B%90%EC%8B%9C%EC%9E%90%EB%A3%8C%ED%98%95,-%EC%B0%B8%EC%A1%B0%EC%9E%90%EB%A3%8C%ED%98%95.html",
            "relUrl": "/%EC%9B%90%EC%8B%9C/%EC%B0%B8%EC%A1%B0/%EA%B0%9D%EC%B2%B4/%EC%9E%90%EB%A3%8C%ED%98%95/2022/10/14/%EC%9B%90%EC%8B%9C%EC%9E%90%EB%A3%8C%ED%98%95,-%EC%B0%B8%EC%A1%B0%EC%9E%90%EB%A3%8C%ED%98%95.html",
            "date": " • Oct 14, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Intersection Observer API",
            "content": "Intersection Observer API . 개발 배경 . 기존 scroll 이벤트와 가시성 관찰에 이용되는 getBoundingClientRect의 문제를 해결하기 위함. . scroll 이벤트의 문제점 스크롤 시 짧은 시간에 수 백, 수 천의 이벤트가 동기적 으로 실행될 수 있음. 따라서, 실행되는 이벤트에 대한 리스너로 인하여 상응하는 콜백들이 메인 스레드에 큰 부하를 줄 수 있음. . | getBoundingClientRect의 문제점 일반적으론, 여러 작업이 queue에 쌓여서 한 번의 reflow로 처리하지만, getBoundingClientRect 호출 시, 정확한 위치 정보를 파악하기 위해 여러번의 reflow가 발생됨. . | . Intersection Observer . Intersection Observer는 모든 영역을 사각형으로 취급함.(요소가 사각형이 아니더라도, 요소의 모든 부분을 픽셀과 같이 작은 사각형으로 가정하여 가시성을 계산함.) 루트 요소와 타겟 요소의 교차점을 관찰하여 타겟 요소가 루트 요소에 들어가거나 벗어날 때, 혹은 두 요소의 교차부분(intersectionRatio)이 변경될 때, 지정한 콜백이 호출됨. 즉, 기존 scroll 이벤트와 다르게 교차점이 관찰될 시, 비동기적으로 실행되며, 가시성이 관측될 때마다 reflow가 발생하지 않아 성능면에서 유리함. | . 사용법 . // callback이 호출되는 상황(조건)을 정의. (root요소를 정의하지 않으면, default로 viewport가 root 요소로 설정됨.) let options = { root: document.querySelector(&#39;#scrollArea&#39;), rootMargin: &#39;0px&#39;, threshold: 1.0, }; // options에 따라 observer 인스턴스 생성. let observer = new IntersectionObserver(callback, options); // 타겟 요소 관찰 시작. let target = document.querySelector(&#39;#listItem&#39;); observer.observe(target); .",
            "url": "https://khakisage.github.io/khakisage_blog/infinite%20scroll/%EA%B0%80%EC%8B%9C%EC%84%B1%20%EA%B4%80%EC%B0%B0/%EA%B0%9C%EB%85%90%20%EC%A0%95%EB%A6%AC/2022/10/12/Intersection-Observer-API.html",
            "relUrl": "/infinite%20scroll/%EA%B0%80%EC%8B%9C%EC%84%B1%20%EA%B4%80%EC%B0%B0/%EA%B0%9C%EB%85%90%20%EC%A0%95%EB%A6%AC/2022/10/12/Intersection-Observer-API.html",
            "date": " • Oct 12, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Event Delegation",
            "content": "Event Delegation . 캡쳐링과 버블링을 통해 구현되는 이벤트 핸들링 패턴 . 캡쳐링이란? . 이벤트가 상위 요소에서 하위 요소의 방향으로 전파되는 것을 의미. . 버블링이란? . 이벤트가 하위 요소에서 상위 요소의 방향으로 전파되는 것을 의미. . Event Delegation(이벤트 위임) . 일반적으로 이벤트를 다루기 위해선 각각의 이벤트에 독립된 이벤트 핸들러를 할당하여 처리를 함. 이벤트 위임은 이벤트가 일어나는 요소들의 공통된 조상에 하나의 이벤트를 할당하여 하위의 요소의 이벤트를 관리할 수 있음. . 활용 예시 . ‘로그인’, ‘회원가입’, ‘검색’의 기능이 들어간 메뉴를 구현할 때, 각각의 버튼에 독립된 핸들러를 할당하는 대신, 위 3가지 버튼이 들어갈 컴포넌트에 이벤트 핸들러를 추가하고, 하위 버튼의 속성으로 data action 속성에 각각의 메서드를 할당하여 이벤트를 관리할 수 있음. . Pros . 버튼 마다 핸들러를 할당해주지 않아도 되어, 초기화가 단순해지고 메모리가 절약됨. | 핸들러가 하나만 작성되기 때문에, 코드가 간결해지고, 구조가 유연해짐. | . Cons . 이벤트 위임에서는 버블링이 전제되는데, 버블링이 불가한 이벤트가 존재함. | 이벤트의 수준과 관계없이 모든 이벤트에 응답이 일어나야 하므로, 상위요소까지 버블링되지 않아도 되는 이벤트에서도 버블링이 일어나서 CPU 작업에 부하가 발생할 수 있음.(실제로는 무시할만한 수준으로 고려하지 않음) | .",
            "url": "https://khakisage.github.io/khakisage_blog/event%20delegation/js%20design%20pattern/%EA%B0%9C%EB%85%90%20%EC%A0%95%EB%A6%AC/2022/10/12/Event-Delegation.html",
            "relUrl": "/event%20delegation/js%20design%20pattern/%EA%B0%9C%EB%85%90%20%EC%A0%95%EB%A6%AC/2022/10/12/Event-Delegation.html",
            "date": " • Oct 12, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Firebase 사용법_2 (with React)",
            "content": "설치 . 먼저 진행중인 리액트 프로젝트에 firebase를 설치해야 합니다. . npm install firebase . 진행중인 리액트 프로젝트에서 npm 명령어로 firebase를 설치합니다. 일단 설치는 완료되었습니다. 이제 연결을 해야합니다. . 연결 . firebase에 회원가입을 진행한 후 콘솔로 이동하여 프로젝트에 추가를 눌러줍니다. 이때, ios나 aos 등이 있지만 저는 웹을 연결해줄 것이기 때문에, 웹 버튼을 클릭합니다. 여기서 중요한 것은 단 하나입니다. 앱 닉네임은 그렇게 중요한 부분은 아니기에 맘에 드는 이름으로 입력해주시면 됩니다. 중요한 것은 ‘SDK 설정 및 구성’ 입니다. 해당 부분에 리액트 프로젝트와 firebase를 연결하기 위해 필요한 configuration이 있습니다. 이것을 가지고 리액트 프로젝트와 연결을 진행해 보겠습니다. . 저의 경우 처음 CRA로 리액트 프로젝트 폴더를 생성한 후 firebase.js 라는 문서를 추가하였습니다. . 가장 먼저, env 파일을 하나 만들어서, 다음과 같이 REACTAPP이라는 접두어를 붙여서 SDK의 정보들을 저장해줍니다. firebase 콘솔에 있는 configuration 의 정보들의 위 양식의 빈칸에 공백이 없게끔 입력하고 저장합니다. 이후, gitignore에 env파일을 추가해서 git에 민감한 정보가 올라가는 것을 방지할 수 있습니다. . env . (REACT_APP_FIREBASE_API_KEY = &#39; &#39;), (REACT_APP_FIREBASE_AUTH_DOMAIN = &#39; &#39;), (REACT_APP_FIREBASE_PROJECT_ID = &#39; &#39;), (REACT_APP_FIREBASE_STORAGE_BUCKET = &#39; &#39;), (REACT_APP_FIREBASE_MESSAGE_SENDER_ID = &#39; &#39;), (REACT_APP_FIREBASE_APP_ID = &#39; &#39;); . 이후 만들어둔 firebase.js 에서 다음과 같이 작성을 합니다. 이 문서에서 firebase와 연결을 하기위하여 firebase 콘솔에 있는 configuration을 이용하여 firebase와 연결을 할 수 있습니다. process.env라는 명령어가 env 문서에 작성된 정보를 참조할 수 있게 합니다. 마지막 줄의 db가 이후에 리액트 프로젝트에서 firebase와 관련된 기능을 사용하기위해 사용될 변수입니다. 변수명은 아무렇게나 작성해주셔도 됩니다. . src/firebase.js . import { initializeApp } from &#39;firebase/app&#39;; import { getFirestore } from &#39;firebase/firestore&#39;; const firebaseConfig = { apiKey: process.env.REACT_APP_FIREBASE_API_KEY, authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN, projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID, storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET, messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID, appId: process.env.REACT_APP_FIREBASE_APP_ID, }; // 파이어베이스의 정보로 파이어베이스 시작 const app = initializeApp(firebaseConfig); // 파이어베이스의 파이어스토어의 인스턴스를 변수에 할당 export const db = getFirestore(app); . 마지막으로, App.js에서 다음과 같이 작성해주고, 터미널 창에서 프로젝트를 시작합니다. 만약 연결이 정상적으로 이루어졌다면, 앞서서 설정해준 앱의 닉네임이 localhost에서 출력되고 있음을 확인하실 수 있습니다. . src/App.js . import { db } from &#39;./firebase&#39;; function App() { return &lt;div className=&quot;App&quot;&gt;{db._databaseId.projectId}&lt;/div&gt;; } export default App; . 오늘은 여기까지! . 파이어베이스를 이용한 작은 웹사이트를 생각중입니다. 적당한 것이 생각나면 추후에 추가할 계획입니다. .",
            "url": "https://khakisage.github.io/khakisage_blog/firebase/firestore/react/2022/09/22/Firebase_%EC%82%AC%EC%9A%A9%EB%B2%95_2.html",
            "relUrl": "/firebase/firestore/react/2022/09/22/Firebase_%EC%82%AC%EC%9A%A9%EB%B2%95_2.html",
            "date": " • Sep 22, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Firebase 사용법_1 (간단한 소개)",
            "content": "파이어베이스란? . . 파이어베이스는 구글에서 서비스하는 앱 개발 플랫폼을 말합니다. 앱 개발에 있어서 백엔드에 해당하는 인증이나 데이터베이스에서 빌드까지, 이외에도 앱 빌드 후 배포 이후에 모니터링과 그 결과물을 분석해주는 기능까지 서비스 하고 있는 한마디로 ‘원툴’ 이라고 생각됩니다.. . 이번에 개인 프로젝트를 하나 진행하게 되면서, 처음 사용을 해 보았고, 여러가지 부분을 제외하더라도 백엔드 지식이 없는 프론트 엔드 개발자가 단독으로 웹페이지를 개발하기에 매우 편리하고 유용하다는 생각이 들었습니다. . 물론 아직 나는 회사에 속해있지 않고, 이제 막 시작하는 주니어 개발자(주니어라고 하기에도 부족하다..)이기에 개인 프로젝트를 진행하면서, 서버에 큰 부담이 필요없는 웹 페이지를 개발하기 때문에 파이어베이스가 최선으로 생각됩니다. 이 말인즉슨, 파이어베이스의 최대 단점은 비용이라고 말할 정도로 내가 지금까지 봤던 파이어베이스 관련 영상에서는 비용적인 부분이 가장 큰 단점이라고 말하고 있습니다.. . 잡설이 길었는데, 본론으로 들어가겠습니다. . Firestore VS Realtime . 파이어베이스에는 두 종류의 데이터베이스가 있다. . 먼저 Firestore는 가장 최신의 파이어베이스의 데이터베이스이다. . NOSQL 이지만, SQL 같음 | 복잡한 계층적 데이터를 정규화 시키기 좋음 | 중복 데이터가 많아도 괜찮음 | 요금은 용량 및 CRUD 횟수로 측정됨 위와 같은 이유로 만약 데이터 하나하나의 용량이 크고, 중복 데이터가 많이 발생하는 경우라면 Firestore를 사용하는게 좋을 것 같습니다. | . 다음으로 Realtime은 기존의 파이어베이스의 데이터베이스이다. . 데이터를 하나의 큰 JSON 객체로 저장함 | 요금은 용량 및 다운로드 크기로 측정됨 데이터 하나하나의 용량이 가볍고, 문서에대한 CRUD가 많이 발생되는 경우라면 Realtime이 더 적합해 보입니다. | . 다음편에는 . 참고로 개인 프로젝트를 진행할 당시, 시간적 압박과 레퍼런스가 더 최신이었던 파이어스토어를 사용했습니다. 그래서, 이번 블로깅에서는 Firestore에 대한 기본적인 사용방법에 대해서 이야기 해보려고 합니다. .",
            "url": "https://khakisage.github.io/khakisage_blog/firebase/firestore/2022/09/20/Firebase_%EC%82%AC%EC%9A%A9%EB%B2%95_1.html",
            "relUrl": "/firebase/firestore/2022/09/20/Firebase_%EC%82%AC%EC%9A%A9%EB%B2%95_1.html",
            "date": " • Sep 20, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "면접질문_4",
            "content": "브라우저 동작 원리 . 브라우저 렌더링 (작동) 원리에 대해 설명하세요. . 가장 먼저 서버로부터 전달 받은 리소스를 브라우저의 렌더링 엔진이 각각 HTML parser와 CSS parser에 의해 파싱됩니다. HTML parser에 의해 파싱된 리소스는 DOM 트리로 빌드되고, CSS parser에 의해 파싱된 리소스는 CSSOM 트리로 빌드됩니다. 그리고, DOM 트리와 CSSOM 트리가 결합되어 렌더링 트리가 형성됩니다. 렌더링 트리를 기반으로 그려질 노드와 이에 대한 스타일값과 치수등을 계산하여 BOX model을 생성합니다. 이러한 정보들을 바탕으로 각각의 노드를 화면에 페인트하여 브라우저가 렌더링됩니다. . | 웹페이지가 사용자에게 보여지는 과정에 대해서 설명하세요. . 현재 페이지에서 다른 페이지로 이동할 때, prompt for unload가 발생합니다. 해당 이벤트는 뒤로가기 버튼이나 링크를 눌러서 다른 도메인으로 이동할 때 발생합니다. 다음으로 redirect가 일어날수 있습니다. 예를 들어서 브라우저에서 A라는 url을 웹 서버에 요청한다면, 서버는 B로 redirect할 것을 지시할 수 있습니다. 이와 같이 브라우저의 url 요청에 대해서 서버가 다른 url로 요청할 것을 지시하는 것을 말합니다. 하지만, redirect는 선택적인 부분이기 때문에, 발생하지 않을 수 있습니다. 다음은 서버에서 데이터를 불러오기 전에 저장된 데이터가 있는지 확인하는 단계인 AppCache 단계입니다. 사용자가 해당 페이지에 방문하려고 했을 때, 임시 저장된 캐시 데이터가 있는지를 확인하고 만약 있다면, 네트워크 통신 없이 바로 사용할 수 있기 때문에 이를 통해 속도를 증가시킬 수 있습니다. 그리고 도메인이 브라우저에 캐시되어 있는지를 확인하고, 없는 경우 DNS를 조회하여 해당 도메인에 대한 IP를 알아냅니다. 알아낸 IP로 TCP 레이어에서 요청을 보내고 요청이 성공적으로 처리되면 응답이 오게 됩니다. 이후에는 브라우저가 렌더링 되는 과정을 거쳐서 최종적으로 렌더과정이 마무리 되어 사용자가 알아볼 수 있게 화면에 보여집니다. . | Client Side Rendering 과 Server Side Rendering 의 차이에 대해서 설명하세요. . csr과 ssr의 가장 큰 차이점은 렌더링이 일어나는 위치가 다릅니다. csr은 브라우저에서 렌더링이 일어나기 때문에 서버와 클라이언트 간의 데이터 트래픽이 감소하고 렌더링이 한번만 일어나기 때문에 페이지 이동이 빠르다는 장점이 있지만, seo 측면에서 불리하고 사용자 정보를 쿠키에 저장해야 해서 보안에 상대적으로 취약하다는 단점이 있습니다. ssr의 경우 서버에서 렌더링을 하기 때문에 seo 측면에서 유리하고, 사용자 정보를 세션에 저장할 수 있어 상대적으로 보안에 강합니다. 하지만, 페이지 변경이 있을 때마다 서버에 요청이 일어나게 되어 서버의 부담이 커진다는 단점이 있습니다. . | 프론트엔드 입장에서 신경써야 할 보안은 어떤 것들이 있나요? | SPA의 장점이 무엇인가요? . SPA는 하나의 페이지로 구성되어 있고, 클라이언트에 모든 페이지가 있기 때문에, 휴대폰의 앱과 같은 UX를 제공합니다. 서버 측에서 렌더링이 일어나지 않기 때문에 서버의 부담이 적어지고, 모듈화 및 컴포넌트 단위의 개발이 용이하다는 장점이 있습니다. . | lazy loading이 무엇인가요? . 페이지를 읽어들이는 시점에서 중요하지 않은 리소스의 로딩을 지연시키는 기술을 말합니다. 예를 들어서 사용자가 웹 페이지에 방문했을 때, 해당 페이지의 모든 내용을 확인한다는 보장이 없기 때문에, 만약 사용자가 일부분만을 확인하고 웹 페이지를 벗어나게 되면, 결과적으로 메모리 및 대역폭의 낭비가 발생하게 됩니다. 따라서, lazy loading을 이용하면 통신 비용을 절약하고 웹 성능을 향상시킬 수 있습니다. . | 웹페이지 redirect의 다양한 구현법에 대해서 설명하세요. . 3가지의 구현방법이 있습니다. 먼저 HTTP redirect 입니다. HTTP redirect는 300번대의 상태코드를 응답합니다. 해당 상태코드를 수신한 브라우저는 제공된 새로운 url을 이용하여 즉시 로드합니다. 다른 방법으로 태그와 http-equiv 속성을 사용하여 HTML redirect를 할 수 있습니다. 하지만, 이 경우에 브라우저에서 뒤로가기 버튼을 사용할 수 없게 만들기 때문에 지양해야하는 방법입니다. 마지막으로 DOM을 사용하는 자바스크립트 redirect가 있습니다. window.location 프로퍼티에 값을 설정해서 새로운 페이지를 로드할 수 있습니다. . | Reflow가 발생하는 이유와 방지 방법은 무엇인가요? . 리플로우는 브라우저의 렌더링을 위해 문서 내 요소의 위치와 도형을 계산하기 위해 발생합니다. 리플로우 과정에서 결국 사용자는 브라우저를 이용할 수 없기 때문에 최소화 해야합니다. 리플로우를 최소화 하는 방법으로는 css 규칙을 최소화하고 사용하지 않는 규칙들은 삭제해야하고, 애니메이션 효과 같은 복잡한 렌더링의 경우에는 position 값을 fixed나 absolute로 지정하여 전체 노드의 흐름과 분리시켜서 최소화 할 수 있습니다. . | 디자인 패턴이란 무엇이고 각각의 장단점에 대해서 설명하세요. | 네트워크 프로토콜 . OSI 7계층에 대해 설명해주세요. | TCP와 UDP 방식의 차이점을 설명해주세요. . | TCP의 3 Way-HandShake와 4 Way-HandShake에 대해서 알고 있나요? | DNS에 대해 설명해주세요. . Domain Name System의 약어로, 사람이 읽을 수 있는 언어로 된 주소를 컴퓨터가 이용할 수 있는 숫자 형식의 IP로 변환하여 서로 통신이 가능하게 합니다. DNS는 전화번호부 처럼 이름과 숫자 간에 매핑을 관리하기 때문에, 호스트의 도메인 이름을 IP 주소로 변환하여 사용자가 도메인 이름을 웹 브라우저에 입력할 때 해당 사용자를 해당 서버에 연결시켜 줍니다. . | 프록시 서버가 필요한 이유에 대해 설명해주세요. . 첫번째는 캐시데이터를 사용하기 위함입니다. 클라이언트와 서버간 통신에서 필요한 리소스가 프록시 서버에 저장되어 있다면 따로 서버에 재요청 없이 사용할 수 있기 때문에 트래픽도 감소시킬 수 있고, 네트워크의 병목 현상도 방지할 수 있습니다. 둘째로 보안 목적입니다. 프록시 서버를 경유하는 경우 IP를 숨길수 있고, 또한 방화벽으로 사용하는 경우도 있기 때문입니다. 마지막으로, 접속 우회를 위해 사용할 수 있습니다. 사용자가 위치한 국가에서 사이트로의 접속이 제한되는 경우, 프록시 서버를 사용하여 접속이 제한된 사이트의 서버와 마치 접속된 것처럼 속일 수 있기 때문에 접속 우회에 사용됩니다. . | HTTP . Http와 Https 통신 방식의 차이에 대해 설명해주세요. | HTTP 프로토콜에 대해 설명해주세요. . HTML 문서와 같은 리소스를 가져올 수 있게 해주는 프로토콜을 말합니다. 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동되며, 기본적으로 어떤 종류의 데이터라도 전송할 수 있게 설계되어 있습니다. HTTP 프로토콜은 클라이언트와 서버간 프로토콜의 모델을 따르며, 클라이언트에서 요청을 보내면 서버에서 응답을 하는 방식으로 이루어집니다. . | 무상태와 비연결성에 대해 설명해주세요. . HTTP는 인터넷 상에서 블특정 다수와의 통신을 위해 설계되었습니다. 때문에, 다수의 클라이언트와 지속적으로 연결을 유지하게 되면 많은 리소스가 필요해지고, 서버의 부담도 매우 커지게 됩니다. 따라서, 클라이언트가 서버와의 통신을 위해 요청을 보내고 응답을 받게 되면 연결이 끊어지는데 이 성질을 비연결성이라고 합니다. 또한 이러한 비연결성으로 인해 야기되는 특성이 있는데, 바로 무상태성입니다. 클라이언트와 서버가 한번 통신을 주고 받으면 연결이 끊어지기 때문에, 서버는 클라이언트를 식별할 수 없게 됩니다. 즉 새로고침을 하게 되면 클라이언트의 사용자 정보가 사라지게 됩니다. 이것을 해결하기 위해 로컬에 사용자 정보를 저장하는 쿠키나 서버에 저장하는 방식인 세션, 이외에도 토큰 등으로 이러한 무상태성을 해결할 수 있습니다. . | REST API에 대해 설명해주세요. . REST API란 REST 아키텍처의 조건을 준수하는 API를 말합니다. 여기서 REST란 Representatinal State Transfer의 줄임말입니다. 즉, 통신에 필요한 리소스를 이름으로 구분하여 해당 리소스의 상태를 주고받는 것을 의미합니다. 보다 자세히 말하면, HTTP URI를 통해 해당 리소스를 명시하고, HTTP 메서드를 통해 해당 리소스에 대한 CRUD 기능을 적용하는 것을 의미합니다. 추가적으로, REST의 특징은 5가지 정도로 정리할 수 있습니다. 먼저 클라이언트와 서버로 구조가 나뉘어져 있습니다. 따라서, 서버는 api를 제공하고, 클라이언트는 사용자 인증이나 컨텍스트등을 관리하여 개발과정에서 그 영역이 명확하게 구분되고 서로에 대한 의존성이 줄어듭니다. 둘째로, 무상태성을 가집니다. 작업을 위해 상태정보를 저장하지 않기 때문에, 세션이나 쿠키의 정보를 별도로 저장하지 않아 api 서버는 단순하게 들어오는 요청만 처리하면 됩니다. 때문에, 서버에서 불필요한 정보를 관리하지 않아도 되어 구현이 단순해집니다. 셋째로, http라는 웹표준을 사용하기 때문에 기존 http가 가지는 캐싱 기능을 사용할 수 있습니다. 넷째로, 자체 표현 구조로 되어 있어서 REST API의 메시지 만으로 이해가 가능합니다. 마지막으로, 계층형 구조를 가지고 있어서 보안이나, 로드 밸런싱 등의 계층을 추가하여 구조적으로 유연함을 가지고 프록시나 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있습니다. . | GET 메서드와 POST 메서드의 차이점에 대해 설명해주세요. . GET 메서드의 경우 서버로부터 특정 정보를 가져오기 위해 사용되는 메서드입니다. 이때, 요청을 위해 URL 주소 끝에 파라미터로 쿼리 값을 전달하여 특정 정보를 요청합니다. POST 메서드의 경우 리소스를 생성 혹은 업데이트를 하기위해서 서버로 데이터를 보낼 때 사용합니다. GET과 다르게 전송해야할 데이터를 HTTP 메시지의 body부분에 담아서 전송합니다. 차이점을 간단하게 말하자면 GET 메서드의 경우 서버로부터 정보를 조회하기 위해 설계된 메서드이고, POST 메서드는 서버로 특정 리소스를 생성 및 변경하기 위해 설계된 메서드입니다. 즉, GET의 경우 멱등성을 가집니다. GET 메서드를 여러번 사용해도 결과는 항상 동일합니다. 반대로, POST의 경우 멱등성을 가지지 않아, 동일한 요청을 보내도 그 응답은 다를 수 있다는 점에서 차이가 있습니다. . | PUT 메서드와 PATCH 메서드의 차이점에 대해 설명해주세요. . PUT과 PATCH 메서드는 모두 리소스를 업데이트한다는 점에선 그 목적이 동일합니다. 하지만, 두 메서드간의 차이는 PUT 메서드는 리소스의 모든 것을 업데이트합니다. 예를 들어서 어떠한 웹사이트의 회원정보에는 이름, 나이, 그리고 성별이라는 정보가 있고, 사용자가 자신의 회원정보를 변경하기 위해, PUT 메서드로 회원정보 중 이름만 전송하게 된다면, 해당 회원정보에는 이름 이외에 나이와 성별은 null 값으로 변경됩니다. 하지만, PATCH메서드로 동일하게 이름만 전송한다면, 기존 회원정보는 유지되고, 요청에 포함된 이름만 변경된다는 차이점이 있습니다. . | Expires, Date, Age, If-Modified-Since의 차이점에 대해 설명해주세요. . | If-Modified-Since와 If-None-Match의 차이점에 대해 설명해주세요. . | 브라우저 저장소에 대해서 설명해주세요. . 브라우저 저장소란 해당 도메인과 관련된 데이터를 클라이언트의 웹 브라우저에 저장할수 있게 해줍니다. 브라우저 저장소는 크게 Cookie와 Web Storage로 구분됩니다. 쿠키는 매번 서버로 전송되고, 데이터 저장 용량에 제한이 있고, 만료일이 설정되어 있어 언젠가는 사라집니다. 또한, 암호화 되지 않아 보안에 취약다는 등의 단점을 가집니다. 이러한 쿠키의 단점을 극복하기 위해 Web Storage를 사용합니다. Web Storage는 클라이언트에 저장된 데이터가 서버로 전송되지 않기 때문에 네트워크 비용을 절감할 수 있고, 저장 용량에 제한이 없습니다. 또한 영구적으로 데이터 저장이 가능하다는 장점을 가집니다. Web Storage는 데이터의 지속 여부에 따라 Local Storage와 Session Storage로 나눌 수 있습니다. Local Storage의 경우 브라우저를 닫았다가 다시 열어도 계속 유지되지만, Session Storage의 경우 새로고침하는 경우에는 유지되지만, 브라우저를 닫게 되면 해당 저장소의 내용도 삭제됩니다. . | HTTP 상태 코드에 대해서 설명하세요. . HTTP 상태 코드는 특정 HTTP 요청이 성공적으로 완료되었는지를 알려주기 위해 사용됩니다. 상태코드는 3자리로 이루어져 있으며 가장 앞자리는 1부터 5까지 총 5개의 그룹으로 나누어집니다. 1부터 순서대로 정보를 제공하는 응답, 성공했다는 응답, 리다이렉트, 클라이언트 에러, 마지막으로 서버에러로 나뉩니다. . | 보안/인증 . CORS에 대해 설명해주세요. | CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가요? 어떤 옵션을 통해서 해결하셨나요? | Preflight Request에 대해 설명해주세요. | same-origin 정책에 대해 설명해주세요. | 로컬과 실제 환경 배포할 때의 CORS 세팅에 있어서 주의해야 할 점에 대해 설명해주세요. | SSL 인증서 암호화 기법인 대칭키 암호화 기법, 공개키 암호화 기법에 대해 설명해주세요. | OAuth에 대해서 간단히 설명해주세요. | Session과 Cookie, Token, 그리고 Web Storage의 차이에 대해 설명해주세요. |",
            "url": "https://khakisage.github.io/khakisage_blog/browser/http/network/%EB%B3%B4%EC%95%88/%EC%9D%B8%EC%A6%9D/2022/09/13/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_4.html",
            "relUrl": "/browser/http/network/%EB%B3%B4%EC%95%88/%EC%9D%B8%EC%A6%9D/2022/09/13/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_4.html",
            "date": " • Sep 13, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "면접질문_3",
            "content": "CSS . CSS보다 SCSS/SASS가 가진 장점에 대해 설명하세요. . SCSS와 SASS는 기존의 CSS를 보다 편리하게 사용할 수 있게 만들어진 확장판 스크립트 언어입니다. 첫번째 장점은 중첩입니다. 중첩 구문을 사용해서 상위 선택자의 반복을 피하고, 더 편리하게 복잡한 구조를 작성할 수 있습니다. 두번째는 변수 할당입니다. 반복적으로 사용되는 값을 변수에 할당하여 코드를 보다 가독성있게 작성할 수 있습니다. 세번째는 비교, 산술, 논리 연산자의 사용이 가능하여 속성값의 연산이 가능합니다. 네번째는 확장입니다. extend를 사용하여 css의 속성 집합을 다른 곳에서 상속받아 사용할 수 있습니다. 마지막으로 믹스인입니다. 이 기능은 자주 사용하는 스타일을 믹스인 지시어로 정의하고, 이것을 include라는 지시어로 언제든지 정의된 스타일을 다시 사용할 수 있습니다. . | CSS, SCSS, SASS의 차이점과 리액트와 사용할 거면 무엇을 쓸 건지 설명하세요. . SCSS와 SASS는 CSS에 기능을 추가한 일종의 전처리기입니다. CSS파일은 아니기 때문에, SCSS나 SASS로 작성된 파일은 CSS파일로 컴파일 된 후에 동작합니다. 여러가지 기능의 추가로 기존 CSS로 작성된 파일보다 더 가독성 있고, 유지보수가 쉬운 형태로 작성할 수 있습니다. SCSS와 SASS와의 차이는 기능적으론 차이가 없으나 SASS의 경우 들여쓰기와 줄바꿈형식을 사용하고 SCSS는 중괄호와 세미콜론으로 구분을 하는 차이가 있습니다. 리액트와 사용한다면 SCSS를 사용하는 것이 더 효율적이라고 생각됩니다. SCSS가 기존 CSS와 문법적으로 비슷하기 때문에 더 익숙한 SCSS를 사용하는게 효율적인 면에서 우수하다고 생각합니다. . | id와 class 셀렉터의 차이점에 대해 설명하세요. . 먼저 id의 셀렉터는 #을 사용합니다. 그리고 파일 내부에서 유일한 요소를 식별하기 위해 사용되는 셀렉터입니다. class의 경우 파일 내부에서 공통되는 요소를 그룹화해서 식별하기 위해 사용되는 셀렉터 입니다. class는 셀렉터로 .를 붙여서 사용합니다. id의 셀렉터가 class의 셀렉터보다 그 우선순위가 높아서 만일 어떤 요소에 id와 class의 속성이 동시에 있다면 id의 속성값을 우선합니다. . | CSS 박스 모델에 대해서 설명하세요. . 레이아웃을 계산할 때, 총 4가지 영역을 사각형의 박스로 표현하는데, 이것을 박스 모델이라고 합니다. 먼저 실제 내용 즉, 텍스트나 이미지 등 셀제 요소를 포함하는 콘텐츠 영역이 있습니다. 그리고 콘텐츠와 테두리 사이의 패딩 영역 즉, 안쪽 여백이 있고, 그 패딩을 감싸는 볼더 영역이 있고, 테두리를 기준으로 이웃하는 요소 사이의 간격을 의미하는 마진 영역이 있습니다. . | CSS에서 px, em, rem, vh, vw 단위들의 차이점은 무엇인가요? . CSS에서 너비나 높이를 표현하기 위해서 사용되는 단위들이 있는데, 이 단위는 절대길이와 상대길이 단위로 나누어집니다. 먼저 px은 절대길이 단위로 다른 요소의 크기와 관계 없이 항상 동일하게 고정됩니다. 이외의 나머지 단위들은 모두 상대길이 단위입니다. 먼저 em과 rem은 글꼴의 크기를 나타낼 때 사용됩니다. em은 부모 엘리먼트의 폰트 사이즈를 기준으로 합니다. rem은 최상위 엘리먼트의 폰트 사이즈를 기준으로 합니다. vh와 vw는 뷰포트 즉, 웹사이트에서 보여지는 영역을 기준으로 계산됩니다. h와 w는 각각 높이와 너비를 의미하며, 계산은 뷰포트의 높이나 너비의 퍼센트 만큼 계산합니다. . | CSS 레이아웃 기법의 종류와 특징에 대해서 설명하세요. (grid, flexbox) . flex와 grid는 웹의 레이아웃을 잡기위해 사용하는 기법입니다. 먼저, flex의 경우 1차원의 레이아웃을 위해 사용됩니다. 즉, 속성을 정의할때, 한번에 하나의 방향만 설정할 수 있습니다. grid의 경우 2차원의 레이아웃을 위해 사용됩니다. 즉, 속성을 정의할 때, 행과 열을 모두 고려해서 레이아웃을 잡을 수 있습니다. . | CSS in JS(styled component)의 장단점에 대해서 설명하세요. . styled component의 장점으로는 class명이 빌드 시 유니크한 해시값으로 변경되기 때문에, 별도의 명명규칙이 필요하지 않아 간단하고, css가 컴포넌트 단위로 모듈화되어 의존성을 고려하지 않아도 됩니다. 또한, css코드를 자바스크립트 파일에 작성하기 때문에, 동적으로 코딩을 할 수가 있으며, 컴포넌트 스코프에서만 적용되기 때문에 스타일의 우선순위 문제가 발생하지 않습니다. 단점으로는 라이브러리를 사용해야 하기 때문에 번들의 크기가 커지고, css 와는 다른 방식 즉, 자바스크립트의 css 코드를 파싱하여 적용을 하기 때문에 상태값이 변경되는 경우 다시 파싱하여 적용하기 때문에 상대적으로 적용되는 속도가 느리다는 단점이 있습니다. . | position 속성과 z-index의 연관성에 대해 설명하세요. . position 속성은 문서 상에서 요소를 배치하는 방법을 지정할 때 사용합니다. 때문에, position 속성이 없는 태그들과의 우선순위에서 우위를 차지합니다. position 속성이 있는 태그들끼리 비교한다면, 나오는 순서대로 쌓이게 됩니다. z-index는 position 속성을 가지는 태그들 중에서 보여지는 우선순위를 정할 때 사용됩니다. z축 상의 위치를 나타내는데, 여러장의 레이어가 쌓인 페이지를 생각했을 때, 레이어가 0일때를 기본 렌더링 레이어라고 생각하고, 이때, z-index의 값은 0입니다. 그리고 값이 음수로 작아질 수록 그 우선순위가 가장 낮아지고, 양수로 커질수록 우선수위가 가장 가까워집니다. . | Javascript 심화 . event loop에 대해서 설명하세요. . 자바스크립트가 실행되는 환경은 여러개의 스레드로 이루어져 있는데, 싱글스레드인 자바스크립트 엔진과의 연동을 위해서 이벤트 루프가 사용됩니다. node.js를 구성하는 요소 중 하나인 libuv 라이브러리 에서는 어떤 이벤트가 들어오면 해당 이벤트를 event queue에 넣고 stack이 비어있는지를 확인하면서 큐에서 대기중인 이벤트를 스택에 넣어줍니다. 이 과정을 이벤트 루프라고 하고 이를 통해서 작업의 동시성을 구현할 수 있습니다. . | callback, promise, async/await 의 특징과 차이점에 대해서 설명하세요. . 이 세가지는 모두 자바스크립트에서 비동기 처리에 이용됩니다. 먼저 callback 은 함수의 인자로 함수를 받아들였을 때, 인자로 받아들인 함수를 다시 호출하는 기능을 말합니다. 물론 callback은 비동기에만 사용되는 것은 아닙니다. map() 메소드에서 사용 시 , 동기적으로 사용될 수 있습니다. callback의 경우 연속적으로 사용시, 이른바 callback hell에 빠지며, 유지보수가 어렵고, 가독성이 떨어지는 단점이 존재합니다. promise의 경우, callback과 그 사용목적은 동일하지만, cb가 작업이 끝난 후에 함수를 호출한다면 promise는 작업이 끝나면 promise 객체를 생성하고, 메소드인 .then()을 호출합니다. callback과 비교하여, 코드가 간결해지고, 상대적으로 유지보수와 가독성이 향상됩니다. 하지만, promise의 경우, 모든 에러를 .catch 로 처리하기 때문에, 코드에서 에러가 발생했을 때, 에러를 명확하게 파악하기 힘들다는 단점이 있습니다. async/await은 이러한 promise의 단점을 보완하고자 만들어진 비동기 처리방법입니다. promise와 다르게 try-catch 문을 사용해서 예외처리도 각각 해줄 수 있어서 명확하게 에러를 파악할 수 있습니다. . | Blocking과 Non-Blocking의 차이점은 무엇인가요? . a와 b라는 함수가 있다고 가정했을 때, a함수가 b함수를 호출하는 과정에서 제어권을 어떻게 처리하느냐에 따라 그 차이가 있습니다. 먼저 블로킹은 a함수가 b함수를 호출하면 자신이 실행하던 것을 멈추고 제어권을 b함수에게 넘깁니다. 그리고 b함수는 함수를 실행하고 실행이 종료되면 다시 제어권을 a함수로 넘깁니다. 이 방식을 블로킹이라고 합니다. 다음으로 논블로킹방식은 a함수가 b함수를 호출하면 b함수가 실행되더라도 제어권은 여전히 a함수가 가지고 있어서 자신의 함수를 실행하는 것을 의미합니다. 즉, 제어권이 어디에 있느냐에 따라서 블로킹과 논블로킹으로 나누어진다고 생각할 수 있습니다. . | Synchronous execution과 Asynchronous execution의 차이점은 무엇인가요? . 실행방식의 차이가 있습니다. synchronous한 방식은 하나의 작업이 끝난 후에 다음 작업이 실행됩니다. 싱글 스레드 뿐만아니라 멀티 스레드라고 하더라도 하나의 작업이 끝날 때까지 다음작업은 시작할 수 없습니다. asychronous한 방식은 여러 스레드에서 여러 작업이 동시에 시작하여 작업될 수 있습니다. . | nodejs는 싱글쓰레드인가요? . 아닙니다. node.js 자체는 여러개의 스레드를 가지지만, 브라우저에 내장된 자바스크립트 엔진이 싱글스레드 방식입니다. node.js는 자바스크립트 엔진인 V8과 libuv 라이브러리로 구성되어 있는데, 비동기 처리가 필요해질 경우 node api를 통해 libuv 라이브러리에 이벤트를 넣어주고 libuv가 해당 이벤트를 큐에 넣어놓고 스택이 비어있는지를 확인하면서 큐에서 스택으로 이벤트를 넘겨줍니다. 이 과정을 이벤트 루프라고 말하고, 이벤트 루프를 통해서 작업 동시성을 구현할 수 있습니다. . | nodejs는 event-driven architecture 인가요? . node.js 는 이벤트리스너에 콜백함수를 등록해놓습니다. 따라서 시스템에서 어떠한 이벤트가 발생했을 때, 해당 이벤트에 대한 콜백함수가 호출되는 방식으로 이벤트를 처리해주기 때문에 event-driven-architecture라고 할 수 있습니다. . | this와 dynamic scoping . | 객체 지향 프로그래밍이란 무엇인가요? . 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 방법을 말합니다. 객체 지향 프로그래밍에는 여러가지 특징이 있습니다. 먼저 데이터와 기능을 한 곳에 묶어서 클로저함수로 감싸주는 은닉화와 이 과정에서 복잡한 과정은 안으로 숨겨지고 간단한 것만 노출되는 추상화가 있습니다. 그리고 부모 클래스로부터 그 특징을 자식 클래스가 상속을 받아서 그대로 사용할 수 있고, 마지막으로 다형성이 있습니다. 같은 형태의 코드지만 내부의 메소드에 따라서 여러가지 형태를 지닐 수 있습니다. . | Prototype Chaining . 기존에 존재하는 객체를 기반으로 새로운 객체를 생성하는 것을 말합니다. 객체의 프로퍼티에 접근하였을 때, 해당 프로퍼티가 없다면 proto라는 접근자 프로퍼티를 통해서 부모 역할의 객체를 순차적으로 돌아다니면서 검색하여 해당 프로퍼티가 존재하면 그 프로퍼티를 상속받을 수 있습니다. . | IIFE . 즉시 호출 함수 표현식을 말합니다. 특정 상황에서 데이터를 전역 변수에 담지 않고, 해당 데이터에 side-effect를 방지하기위해서 사용됩니다. . | setTimeout 에서 this는 왜 전역을 가리키는지 설명하세요. . | 스택과 힙의 차이에 대해서 설명하세요. . 자바스크립트에서 메모리를 관리하기 위해 사용하는 자료구조입니다. 힙은 참조형 데이터가 저장되고, 스택은 원시타입의 데이터가 저장됩니다. . | call-by-value에 대해서 설명하세요. . 함수의 호출 방식을 말합니다. 함수의 인자로 어떠한 변수의 값을 사용할 떄, 해당 변수의 값은 복사된 값으로 전달되고, 함수 내부에서는 해당 값의 변화가 일어나지만, 변수의 원래의 값에는 변화가 일어나지 않습니다. . |",
            "url": "https://khakisage.github.io/khakisage_blog/javascript/css/2022/09/05/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_3.html",
            "relUrl": "/javascript/css/2022/09/05/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_3.html",
            "date": " • Sep 5, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "면접질문_2",
            "content": "React . 개념과 장점, 그리고 컴포넌트란 무엇인가요? . 리액트는 주로 SPA를 만들때 사용되는, 사용자 인터페이스를 구축하기 위한 자바스크립트 라이브러리를 말합니다. . 리액트의 장점으로는 우선, virtual DOM을 사용합니다. virtual DOM을 사용하여, 브라우저가 렌더링 될때 일어나는 리플로우와 리페인트의 연산을 최소화하여 웹페이지의 성능을 최적화 할 수 있습니다. 둘째로, 컴포넌트의 가독성이 높고 간단하여 유지보수 및 재사용이 용이합니다. 또한, 리액트는 라이브러리이기 때문에 다른 프레임워크와 혼용이 가능하다는 장점이 있습니다. . 컴포넌트란 소프트웨어에서 독립적인 기능을 수행하는 일종의 모듈을 말합니다. 휴대폰이나 컴퓨터와 같은 하드웨어와 같이 이러한 컴포넌트들을 조립하여 소프트웨어를 개발할 수 있습니다. . | 리액트의 내부 작동 원리를 재조정 (Reconciliation) 개념과 함께 설명하세요. . 리액트에서는 브라우저를 렌더링 할 때, 실제 DOM과 동일한 가상의 DOM을 메모리에 만들어서 DOM 조작이 발생했을 때, 가상 돔에서 모든 연산을 수행합니다. 그리고 실제 DOM과 비교하는 작업인 Reconcilaition을 통해 실제 DOM을 갱신시켜서 그 결과를 반영하여 렌더링합니다. . | 리액트에 있는 라이프사이클과 각 라이프사이클의 역할을 설명하세요. . React의 라이프 사이클은 크게 3가지 유형으로 구분됩니다. 첫번째는 DOM이 생성되고 웹 브라우저 상에서 나타나는 단계인 Mount입니다. 두번째는 props나 state가 바뀔때, 부모 컴포넌트가 리렌더링 될때, 혹은 강제로 업데이트될때 나타나는 단계인 Update 입니다. 마지막 단계는 DOM에서 제거되는 단계인 Unmount 입니다. . | Class Component의 생명주기 메소드에 대해서 설명하세요. . mount, update, unmount에 따라 3종류로 나뉘어집니다. . 먼저 컴포넌트가 mount될 때, 컴포넌트를 만들기 위해 사용되는 constructor, props의 값을 state에 동기화 시킬 때 사용되는 getDerivedStateFromProps(), UI를 렌더링하는 render(), 그리고 컴포넌트가 첫 렌더링을 마치고 호출되는 componentDidMount() 메서드가 있습니다. . 다음으로는 컴포넌트가 업데이트 즉, props나 state가 변경될 때 사용되는 메서드들이 있습니다. props의 변화에 따라 state값에 변화를 주고 싶을 때 사용하는 getDerivedStateProps(), 그리고 이에 따라 props나 state의 값이 변경되었을 때 렌더링 여부를 물어보는 shouldComponentUpdate()메소드, 렌더링 하기로 결정되었다면 이를 리렌더링 해주는 render() 메소드, 컴포넌트의 변화를 DOM에 반영하기 직전에 호출하는 getSnapshotBeforeUpdate(), 최종적으로 컴포넌트의 업데이트가 끝난 후 호출되는 componentDidUpdate()메소드가 있습니다. . 마지막으로 컴포넌트가 unmount될 때, 컴포넌트를 DOM에서 제거할 때 호출되는 componentWillUnmount()메소드가 있습니다. . | 리액트 라우터같은 Client Side Routing 에 대해서 설명하세요. . 주소에 따라서 다른 화면이 보여지는 것을 라우팅이라고 하는데, 리액트의 경우 client side routing을 합니다. 이 말은 화면의 전환 및 주소 값의 변경이 서버가 아닌 클라이언트 측에서 일어난다는 뜻입니다. client side routing을 통해서 클라이언트와 서버간의 데이터 트래픽이 감소시킬 수 있고, 보다 자연스러운 페이지 이동을 통해서 사용자 경험에도 이점이 있습니다. 하지만, 검색엔진 최적화에 불리하고, 사용자의 정보를 클라이언트 기반의 쿠키에 저장하기때문에, 보안에 취약하다는 단점이 있습니다. . | state를 직접 변경하지 않고 setState를 사용하는 이유에 대해서 설명하세요. . 리액트를 구성하는 컴포넌트의 라이프 사이클을 고려했을 때, state가 변경되면 일련의 과정을 통해 render()메소드가 실행되어 브라우저의 리렌더링이 일어납니다. 하지만, state를 직접 변경하게 되면 render()메소드를 호출하지 않아서 상태가 변경되었더라도 렌더링이 일어나지 않을 수 있기 때문에 setState와 같은 상태변경함수를 사용합니다. . | Props Drilling 이란 무엇인가요? . Props Drilling 이란 단순하게 말하자면 props를 하위컴포넌트로 전달하는 목적의 컴포넌트를 사용해서 props를 전달하는 과정을 말합니다. props drilling 에서 props가 통과하는 컴포넌트의 갯수가 늘어날수록 코드가 복잡해지고 props를 추적하기도 어려워집니다. 이를 해결하기 위해 주로, 리덕스나 리코일과 같은 상태관리 라이브러리를 사용합니다. . | 리액트 Hooks의 장점은 무엇인가요? . 클래스형 컴포넌트에서는 라이프사이클을 이용하기 위해서 컴포넌트의 마운트, 업데이트, 언마운트를 각기 다른 메소드로 처리하지만, 리액트에서는 useEffect라는 메소드로 모두 처리할 수 있어서 코드가 간결해지고, 가독성이 좋아지는 장점이 있습니다. . | Class Component와 Function Component의 차이점에 대해서 설명하세요. . | virtual DOM이 무엇인가요? virtual DOM이 좋은 이유에 대해서 설명하세요. . 일반적으로 브라우저가 렌더링 될 때, HTML이 파싱되어 DOM 노드 트리를 구성하고, CSS 파일을 파싱하여 CSSOM도 생성됩니다. 이렇게 렌더 트리가 완성되면 레이아웃 및 페인팅 과정을 통해서 렌더링이 되는데, 이때 HTML 파일에 30개의 변화가 생긴다면, 위의 과정이 30번 일어나게 됩니다. 하지만, virtual DOM의 경우 그 변화를 가상돔에 적용을 완료한 후에 그 결과를 실제 DOM에 전달하기 때문에 렌더링은 단 한번만 일어나게 되어 성능적으로 유리합니다. . | JSX가 무엇인가요? . javascript의 확장된 문법으로 자바스크립트에 xml이라는 html과 아주 유사한 문자기반의 마크업 언어가 추가된 언어를 말합니다. . | 웹 성능 향상을 위해 최적화를 해 본 경험이 있나요? 혹은 useMemo와 useCallback 메소드를 활용해 최적화하는 원리에 대해서 설명하세요. . 기억을 하는 메소드라고 생각할 수 있습니다. . | React 에서 상태 변화가 생겼을 때, 변화를 어떻게 알아채는지에 대해서 설명하세요. . 리액트에서는 상태를 immutable하게 관리하기 때문에, 상태의 변화가 일어나면 메모리 내부의 값이 변경되는 것이 아니라 새로운 주소를 생성하여 상태를 변경해주기 때문에, 주소값의 변화로 상태의 변화를 파악할 수 있습니다. . | 여러가지 상태 관리 라이브러리(Apollo, Redux, MobX 등)의 차이점에 대해서 설명하세요. . | useEffect 메소드로 componentWillUnmount 가 동작할 수 있는 방법에 대해서 설명하세요. . |",
            "url": "https://khakisage.github.io/khakisage_blog/react/2022/08/29/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_2.html",
            "relUrl": "/react/2022/08/29/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_2.html",
            "date": " • Aug 29, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "DOM (Document Object Model)",
            "content": "DOM . Document Object Model의 약자로, 웹페이지를 구성하는 HTML element를 JS의 객체처럼 조작할 수 있는 구조를 말한다. . DOM Method . DOM에는 여러 메소드가 있지만, 다른 언어와 마찬가지로 가장 기초적인 CRUD가 존재하며, 추가적으로 적용하는 메소드가 따로 존재한다. . 1. Create . createElement 새로운 element를 변수에 할당할 때, 사용된다. 이때, 주의해야할 점은 아직 DOM의 Tree에 속하지 않았다는 점이다. // 사용 예시 let newDiv = document.createElement(&#39;div&#39;); // newDiv라는 변수에 새로운 div tag를 할당한다. . | . 2. Append . createElement로 생성된 새로운 element를 DOM Tree에 연결해주는 메소드이다. . append Node Object와 DOM string을 연결해줄 수 있고, 한번에 여러가지의 자식요소의 설정이 가능하다. // append let newDiv = document.createElement(&#39;div&#39;); let divChild = document.createElement(&#39;p&#39;); newDiv.append(divChild); divChild.append(&#39;hello world&#39;) // 결과 &lt;div&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt; // 다른 방법 let newDiv = document.createElement(&#39;div&#39;); let divChild = document.createElement(&#39;p&#39;); newDiv.append(divChild, &#39;hello world&#39;); // 결과 &lt;div&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt; . | appendChild append와 달리 Node Object만 연결해줄 수 있으며, Dom string은 연결해줄 수 없고, 한번에 하나의 자식요소만 설정된다. // appendChild let newDiv = document.createElement(&#39;div&#39;); let divChild = document.createElement(&#39;p&#39;); newDiv.appendChild(divChild); // 결과 &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; . 3. Read . 자바스크립트의 경우 값을 조회하기 위해 변수명이나 index, key 값을 사용하지만 DOM의 경우에는 다른 방법을 사용한다. . | querySelector 첫번째 인자에 HTML tag, id, class 를 전달하여 값을 조회할 수 있다. HTML element 중에서 인자로 전달해준 것과 일치되는 것들 중에서 첫번째의 값을 조회한다. | querySelectorAll querySelector과 다르게 전달된 인자와 일치하는 모든 element를 조회한다. 또한 이렇게 조회된 HTML element들은 배열과 유사한 형태로 전달된다. 이것을 Array-like-Object 즉, 유사 배열 혹은 배열형 객체라고 부른다. Array-like-Object는 배열과 같이 for문의 사용이 가능하다. 4. Update . createElement로 생성한 HTML element에 여러 메소드를 사용해서 문자열을 입력하거나 class값을 부여하여 css파일과 연결해줄 수 있다. . | textContent // textContent let newDiv = document.createElement(&#39;div&#39;); newDiv.textContent = &#39;hello world&#39;; // 결과 &lt;div&gt;hello world&lt;/div&gt; . | classList.add // classList.add let newDiv = document.createElement(&#39;div&#39;); newDiv.classList.add(&#39;sth-class&#39;) . 5. Delete . | remove 삭제하려는 element의 위치를 알고 있을 때 사용하는 메소드이다. // remove const container = document.querySelector(&#39;#container&#39;) let newDiv = document.createElement(&#39;div&#39;); container.append(newDiv) newDiv.remove() // container에 append 한 newDiv를 삭제할 수 있다. . | innerHTML = ‘’ 해당 id나 class를 가지는 모든 elementfmf 지울때 사용한다. document.querySelector(&#39;#container&#39;).innerHTML = &#39;&#39;; . | removeChild 자식 element를 지정해서 삭제할 때 사용하는 메소드인데, remove의 경우에는 노드 자체를 메모리에서도 삭제하는 반면, removeChild의 경우 부모 노드와의 관계를 끊어서 DOM Tree와 분리시키는 메소드이다. | .",
            "url": "https://khakisage.github.io/khakisage_blog/dom/javascript/2022/08/23/DOM.html",
            "relUrl": "/dom/javascript/2022/08/23/DOM.html",
            "date": " • Aug 23, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "면접질문_1",
            "content": "HTML . &lt;script&gt;&lt;script async&gt;&lt;script defer&gt; tag에 대해 설명하시오. . 기본적으로 렌더링 과정에서 브라우저는 html 문서를 파싱하다가 &lt;script&gt; tag를 만나면 파싱을 중단하고, 스크립트를 다운로드 -&gt; 파싱 -&gt; 실행 후에 다시 html 문서를 파싱합니다. 렌더링 과정에서 &lt;script async&gt; tag 와 &lt;script defer&gt; tag의 경우 html 문서의 파싱이 중단되지 않고 비동기적으로 스크립트를 다운로드합니다. 다만, &lt;script async&gt; tag의 경우 스크립트의 다운로드가 완료되면 즉시 스크립트가 실행되고 이 순간에는 html 파싱이 정지되고 실행이 완료된 후에 파싱이 진행됩니다. 이때, 스크립트의 실행순서는 코드작성 순서와 무관하게 먼저 다운로드가 완료된 스크립트가 실행됩니다. &lt;script defer&gt; tag의 경우 스크립트의 다운로드가 완료되더라도 html 문서의 파싱이 완료된 후에 스크립트가 실행됩니다. &lt;script async&gt; tag와는 달리 스크립트의 실행 순서를 코드의 작성 순서를 따릅니다. . | 시맨틱 태그에 대해 설명하시오. . 시맨틱 태그는 그 목적과 의미가 분명한 태그를 말합니다. 자주 사용되는 &lt;div&gt;, &lt;span&gt; 태그의 경우 태그 자체만으로는 목적을 알 수 없지만, &lt;form&gt;, &lt;article&gt;, &lt;table&gt; 태그 등은 태그 자체만으로도 그 목적과 의미를 알 수 있습니다. 따라서, SEO를 목적으로 한다면 시맨틱 태그가 중요한 지표로 활용될 수 있고, 이외에도 시각장애인을 위한 화면판독기도 시맨틱 태그를 지표로 사용하기 때문에, 여러 이점이 있습니다. . | DOM . 웹팩과 바벨의 역할에 대해서 설명하세요. | event.preventDefault() 의 역할이 무엇인지 설명하세요. | window.requestAnimationFrame(callback) 의 역할이 무엇인지 설명하세요. | intersection Observer API가 무엇인지 설명하세요. | performance API가 무엇인지 설명하세요. | Bundling이 무엇이며 왜 필요한가요? | 이벤트 위임이 무엇인가요? | 이벤트 버블링이란 무엇이며 막을 수 있는 방법은 무엇인가요? | Javascript . 스코프에 대해서 설명하세요. | 클로져에 대해서 설명하세요. | 클로져의 사용 예제를 알려주세요. | 변수 선언, 초기화, 할당의 차이점에 대해서 설명하세요. | 호이스팅과 Temporal Dead Zone이 어떻게 연관되어있는지 설명하세요. | ES6의 주요 변화점에 대해서 설명하세요. | 원시 자료형, 참조 자료형 | == vs === | 자바스크립트에서 배열의 타입 | undefined와 null 그리고 undeclared의 차이 | rest parameters와 spread syntax | 깊은 복사와 얕은 복사의 차이에 대해서 설명하세요. 자바스크립트에서 깊은 복사를 하는 방법은 무엇인가요? | let, const, var의 차이와 각각의 사용 방법을 설명하세요. | 순수함수란 무엇인가요? |",
            "url": "https://khakisage.github.io/khakisage_blog/html/dom/javascript/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8/2022/08/22/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_1.html",
            "relUrl": "/html/dom/javascript/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8/2022/08/22/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_1.html",
            "date": " • Aug 22, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "타입스크립트_1",
            "content": "타입스크립트란? . 자바스크립트에 ‘타입’을 적용한 언어로, 자바스크립트의 확장된 개념이라고 할 수 있다. 타입스크립트는 자바스크립트와 비교하여 두가지 강점을 가진다. . 에러 방지 | 자동 완성 | . example . function sum(a, b) { return a + b; } sum(20, 30); // 50 sum(20, &quot;30&quot;); // 2030 let result = sum(20, 30); result.toLocaleString(); . 자바스크립트의 경우, sum 함수를 작성하였을 때, 함수의 인자에 숫자가 아닌 문자열이 들어와도 일단 작동은 된다. 다만, 자동으로 문자열로 인식되므로, “2030”으로 출력된다. . function sum(a: number, b: number): number { return a + b; } sum(20, 30); // 50 sum(10, &quot;20&quot;); // &quot;20&quot;은 문자열이므로 b 에 할당될 수 없다는 에러가 발생한다. let result = sum(20, 30); result.toLocaleString(); . 타입스크립트의 경우, sum 함수 작성 단계에서 함수의 인자들의 타입을 미리 정해주었기 때문에, 인자에 문자열이 들어오게 되면, 에러가 발생한다. . 첫째로, 자바스크립트의 경우에는 에디터 상에서 잘못된 점을 발견할 수 없고, 브라우저의 콘솔창에서 확인이 가능하다. 하지만, 타입스크립트의 경우에는 에디터 상에서 오탈자나 잘못된 타입의 인자가 들어온다면 에러가 발생했다는 표시가 나와 에러를 사전에 방지할 수 있다는 장점이 있다. . 둘째로, 자바스크립트의 경우 sum 함수의 결과를 result에 할당하였을 때, result에서 toLocaleString()라는 메서드를 작성 시, 자동완성이 나오지 않으며 직접 다 작성을 해주어야 한다. (이 과정에서, 오류가 발생할지는 미지수이다.) 하지만, 타입스크립트의 경우에는 자바스크립트와 동일하게 작성 시, toLo까지만 입력해도 자동완성되는 메서드가 표시된다. (이 과정에서, 오류가 발생할 확률은 자바스크립트보다 현저히 낮다.) . JSDoc &amp; @ts-check . 앞서 설명한 타입스크립트로 작성을 하지 않더라도, 자바스크립트 환경에서 ‘JSDoc’과 ‘@ts-check’를 이용해서 타입스크립트와 유사한 기능을 사용할 수 있다. . ###JSDoc이란? 공식문서에 따르면, JavaScript 용 API 문서 생성기라고 한다. 다시 말하자면, 흔히 API 문서를 메뉴판에 비유하는 것처럼 JS파일에서 작성되는 모듈, 메서드, 매개변수 등에 보다 자세한 사용방법을 첨부하여, 해당 JS파일에서 ‘이 모듈은 어떻게 사용하셔야 하고, 이 메서드에 인자에는 숫자만 혹은 문자열만 넣어주셔야 오류가 발생하지 않습니다’ 라고 설명해주는 용도로 생각된다. 기본적인 사용방법은 . /** * @생성자 를 넣어서 아래의 코드에 대한 사용 방법을 첨부한다. 생성자는 공식문서에 보다 자세하게 나와있다. */ . 위에서 예시로 든 sum 함수를 ‘JSDoc’과 ‘@ts-check’를 사용하여 다시 작성한다면 다음과 같다. . //@ts-check /** * @param {number} a 첫번째 숫자 * @param {number} b 두번째 숫자 */ function sum(a, b) { return a + b; } sum(10, &quot;20&quot;); // 타입스크립트와 마찬가지로 에디터 상에서 오류 표시를 확인할 수 있다. . VSCode 상에서 함수와 오류는 다음과 같이 표시된다. . 결론 . JS파일에서도 ‘JSDoc’ 과 ‘@ts-check’의 조합으로, JS 환경에서도 타입스크립트와 비슷한 느낌(?)으로 사용할 수 있었다. 하지만, 위의 환경으로 작성하는 것보다, 타입스크립트 환경에서 작성하는 것이 보다 덜 힘들게 작성할 수 있고, 보기에도 더 깔끔해보인다. 물론, 내가 만들었던 프로젝트를 TS로 리팩토링하는 과정에서 많은 어려움이 있겠지만 이 시간들이 나에게 큰 도움이 될 것이라고 믿는다. . Stay Focused! .",
            "url": "https://khakisage.github.io/khakisage_blog/typescript/javascript/jsdoc/2022/07/13/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_1.html",
            "relUrl": "/typescript/javascript/jsdoc/2022/07/13/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_1.html",
            "date": " • Jul 13, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "마크다운 포스팅",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://khakisage.github.io/khakisage_blog/markdown/2022/07/12/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4_%ED%85%8C%EC%8A%A4%ED%8A%B8.html",
            "relUrl": "/markdown/2022/07/12/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4_%ED%85%8C%EC%8A%A4%ED%8A%B8.html",
            "date": " • Jul 12, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://khakisage.github.io/khakisage_blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://khakisage.github.io/khakisage_blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "“Stay Focused!” . 개발 이전의 나 . 이리저리 방향을 못잡고, 방황했어요. 매번 새로움을 찾는다고 말하면서, 정작 같은 공부만 10년 정도를 했네요. 처음 4년은 성적에 맞춰 대학을 가서, 식품공학을 공부했어요. 이후, 다시 3년 정도를 더 나은 대학을 가서, 역시 식품공학을 공부했어요. 같은 전공으로 대학원에 진학도 했었어요. 졸업을 한학기 남겨두고, 떠나왔지만 후회는 없어요. . 개발 이후의 나 . 아이디어가 샘솟지는 않지만, 내가 아쉽다고 생각한 것들을 개선할 수 있다는 점에 관심이 생겼어요. 공대를 다녔던 것도 아니었고, 컴퓨터는 게임이나 문서작업 용도로만 썼었고, 터미널 창은 가끔 아이피 주소 확인을 위해서만 열었어요. 처음에는 터미널 창을 열고 명령어만 눌러도 마치 내가 프로그래머가 된 것 마냥 신기하고 그 자체가 멋있었어요. 코딩을 해야겠다고 생각하고, 파이썬으로 입문을 했었는데, 사실 이걸로 그래서 뭘 하는 거지 하는 생각이 있었어요. 웹 개발을 공부하면서, 20년동안 사용해왔던 인터넷이 어떻게 만들어지고, 실행되는지 알게됐는데, 아무것도 모르고 사용했던 과거의 제가 부끄럽네요. 자바스크립트를 기반으로 리액트를 사용하여 웹 페이지를 만들어보았어요. 아직도, 코드를 작성할 때, 구글링을 많이 하고, 매번 수많은 오류에 부딪히지만, 문제들을 해결해가면서 느끼는 성취감이 너무 좋아요. .",
          "url": "https://khakisage.github.io/khakisage_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://khakisage.github.io/khakisage_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}