{
  
    
        "post0": {
            "title": "면접질문_3",
            "content": "CSS . CSS보다 SCSS/SASS가 가진 장점에 대해 설명하세요. . SCSS와 SASS는 기존의 CSS를 보다 편리하게 사용할 수 있게 만들어진 확장판 스크립트 언어입니다. 첫번째 장점은 중첩입니다. 중첩 구문을 사용해서 상위 선택자의 반복을 피하고, 더 편리하게 복잡한 구조를 작성할 수 있습니다. 두번째는 변수 할당입니다. 반복적으로 사용되는 값을 변수에 할당하여 코드를 보다 가독성있게 작성할 수 있습니다. 세번째는 비교, 산술, 논리 연산자의 사용이 가능하여 속성값의 연산이 가능합니다. 네번째는 확장입니다. extend를 사용하여 css의 속성 집합을 다른 곳에서 상속받아 사용할 수 있습니다. 마지막으로 믹스인입니다. 이 기능은 자주 사용하는 스타일을 믹스인 지시어로 정의하고, 이것을 include라는 지시어로 언제든지 정의된 스타일을 다시 사용할 수 있습니다. . | CSS, SCSS, SASS의 차이점과 리액트와 사용할 거면 무엇을 쓸 건지 설명하세요. . SCSS와 SASS는 CSS에 기능을 추가한 일종의 전처리기입니다. CSS파일은 아니기 때문에, SCSS나 SASS로 작성된 파일은 CSS파일로 컴파일 된 후에 동작합니다. 여러가지 기능의 추가로 기존 CSS로 작성된 파일보다 더 가독성 있고, 유지보수가 쉬운 형태로 작성할 수 있습니다. SCSS와 SASS와의 차이는 기능적으론 차이가 없으나 SASS의 경우 들여쓰기와 줄바꿈형식을 사용하고 SCSS는 중괄호와 세미콜론으로 구분을 하는 차이가 있습니다. 리액트와 사용한다면 SCSS를 사용하는 것이 더 효율적이라고 생각됩니다. SCSS가 기존 CSS와 문법적으로 비슷하기 때문에 더 익숙한 SCSS를 사용하는게 효율적인 면에서 우수하다고 생각합니다. . | id와 class 셀렉터의 차이점에 대해 설명하세요. . 먼저 id의 셀렉터는 #을 사용합니다. 그리고 파일 내부에서 유일한 요소를 식별하기 위해 사용되는 셀렉터입니다. class의 경우 파일 내부에서 공통되는 요소를 그룹화해서 식별하기 위해 사용되는 셀렉터 입니다. class는 셀렉터로 .를 붙여서 사용합니다. id의 셀렉터가 class의 셀렉터보다 그 우선순위가 높아서 만일 어떤 요소에 id와 class의 속성이 동시에 있다면 id의 속성값을 우선합니다. . | CSS 박스 모델에 대해서 설명하세요. . 레이아웃을 계산할 때, 총 4가지 영역을 사각형의 박스로 표현하는데, 이것을 박스 모델이라고 합니다. 먼저 실제 내용 즉, 텍스트나 이미지 등 셀제 요소를 포함하는 콘텐츠 영역이 있습니다. 그리고 콘텐츠와 테두리 사이의 패딩 영역 즉, 안쪽 여백이 있고, 그 패딩을 감싸는 볼더 영역이 있고, 테두리를 기준으로 이웃하는 요소 사이의 간격을 의미하는 마진 영역이 있습니다. . | CSS에서 px, em, rem, vh, vw 단위들의 차이점은 무엇인가요? . CSS에서 너비나 높이를 표현하기 위해서 사용되는 단위들이 있는데, 이 단위는 절대길이와 상대길이 단위로 나누어집니다. 먼저 px은 절대길이 단위로 다른 요소의 크기와 관계 없이 항상 동일하게 고정됩니다. 이외의 나머지 단위들은 모두 상대길이 단위입니다. 먼저 em과 rem은 글꼴의 크기를 나타낼 때 사용됩니다. em은 부모 엘리먼트의 폰트 사이즈를 기준으로 합니다. rem은 최상위 엘리먼트의 폰트 사이즈를 기준으로 합니다. vh와 vw는 뷰포트 즉, 웹사이트에서 보여지는 영역을 기준으로 계산됩니다. h와 w는 각각 높이와 너비를 의미하며, 계산은 뷰포트의 높이나 너비의 퍼센트 만큼 계산합니다. . | CSS 레이아웃 기법의 종류와 특징에 대해서 설명하세요. (grid, flexbox) . flex와 grid는 웹의 레이아웃을 잡기위해 사용하는 기법입니다. 먼저, flex의 경우 1차원의 레이아웃을 위해 사용됩니다. 즉, 속성을 정의할때, 한번에 하나의 방향만 설정할 수 있습니다. grid의 경우 2차원의 레이아웃을 위해 사용됩니다. 즉, 속성을 정의할 때, 행과 열을 모두 고려해서 레이아웃을 잡을 수 있습니다. . | CSS in JS(styled component)의 장단점에 대해서 설명하세요. . styled component의 장점으로는 class명이 빌드 시 유니크한 해시값으로 변경되기 때문에, 별도의 명명규칙이 필요하지 않아 간단하고, css가 컴포넌트 단위로 모듈화되어 의존성을 고려하지 않아도 됩니다. 또한, css코드를 자바스크립트 파일에 작성하기 때문에, 동적으로 코딩을 할 수가 있으며, 컴포넌트 스코프에서만 적용되기 때문에 스타일의 우선순위 문제가 발생하지 않습니다. 단점으로는 라이브러리를 사용해야 하기 때문에 번들의 크기가 커지고, css 와는 다른 방식 즉, 자바스크립트의 css 코드를 파싱하여 적용을 하기 때문에 상태값이 변경되는 경우 다시 파싱하여 적용하기 때문에 상대적으로 적용되는 속도가 느리다는 단점이 있습니다. . | position 속성과 z-index의 연관성에 대해 설명하세요. . position 속성은 문서 상에서 요소를 배치하는 방법을 지정할 때 사용합니다. 때문에, position 속성이 없는 태그들과의 우선순위에서 우위를 차지합니다. position 속성이 있는 태그들끼리 비교한다면, 나오는 순서대로 쌓이게 됩니다. z-index는 position 속성을 가지는 태그들 중에서 보여지는 우선순위를 정할 때 사용됩니다. z축 상의 위치를 나타내는데, 여러장의 레이어가 쌓인 페이지를 생각했을 때, 레이어가 0일때를 기본 렌더링 레이어라고 생각하고, 이때, z-index의 값은 0입니다. 그리고 값이 음수로 작아질 수록 그 우선순위가 가장 낮아지고, 양수로 커질수록 우선수위가 가장 가까워집니다. . | Javascript 심화 . event loop에 대해서 설명하세요. . 자바스크립트가 실행되는 환경은 여러개의 스레드로 이루어져 있는데, 싱글스레드인 자바스크립트 엔진과의 연동을 위해서 이벤트 루프가 사용됩니다. node.js를 구성하는 요소 중 하나인 libuv 라이브러리 에서는 어떤 이벤트가 들어오면 해당 이벤트를 event queue에 넣고 stack이 비어있는지를 확인하면서 큐에서 대기중인 이벤트를 스택에 넣어줍니다. 이 과정을 이벤트 루프라고 하고 이를 통해서 작업의 동시성을 구현할 수 있습니다. . | callback, promise, async/await 의 특징과 차이점에 대해서 설명하세요. . 이 세가지는 모두 자바스크립트에서 비동기 처리에 이용됩니다. 먼저 callback 은 함수의 인자로 함수를 받아들였을 때, 인자로 받아들인 함수를 다시 호출하는 기능을 말합니다. 물론 callback은 비동기에만 사용되는 것은 아닙니다. map() 메소드에서 사용 시 , 동기적으로 사용될 수 있습니다. callback의 경우 연속적으로 사용시, 이른바 callback hell에 빠지며, 유지보수가 어렵고, 가독성이 떨어지는 단점이 존재합니다. promise의 경우, callback과 그 사용목적은 동일하지만, cb가 작업이 끝난 후에 함수를 호출한다면 promise는 작업이 끝나면 promise 객체를 생성하고, 메소드인 .then()을 호출합니다. callback과 비교하여, 코드가 간결해지고, 상대적으로 유지보수와 가독성이 향상됩니다. 하지만, promise의 경우, 모든 에러를 .catch 로 처리하기 때문에, 코드에서 에러가 발생했을 때, 에러를 명확하게 파악하기 힘들다는 단점이 있습니다. async/await은 이러한 promise의 단점을 보완하고자 만들어진 비동기 처리방법입니다. promise와 다르게 try-catch 문을 사용해서 예외처리도 각각 해줄 수 있어서 명확하게 에러를 파악할 수 있습니다. . | Blocking과 Non-Blocking의 차이점은 무엇인가요? . a와 b라는 함수가 있다고 가정했을 때, a함수가 b함수를 호출하는 과정에서 제어권을 어떻게 처리하느냐에 따라 그 차이가 있습니다. 먼저 블로킹은 a함수가 b함수를 호출하면 자신이 실행하던 것을 멈추고 제어권을 b함수에게 넘깁니다. 그리고 b함수는 함수를 실행하고 실행이 종료되면 다시 제어권을 a함수로 넘깁니다. 이 방식을 블로킹이라고 합니다. 다음으로 논블로킹방식은 a함수가 b함수를 호출하면 b함수가 실행되더라도 제어권은 여전히 a함수가 가지고 있어서 자신의 함수를 실행하는 것을 의미합니다. 즉, 제어권이 어디에 있느냐에 따라서 블로킹과 논블로킹으로 나누어진다고 생각할 수 있습니다. . | Synchronous execution과 Asynchronous execution의 차이점은 무엇인가요? . 실행방식의 차이가 있습니다. synchronous한 방식은 하나의 작업이 끝난 후에 다음 작업이 실행됩니다. 싱글 스레드 뿐만아니라 멀티 스레드라고 하더라도 하나의 작업이 끝날 때까지 다음작업은 시작할 수 없습니다. asychronous한 방식은 여러 스레드에서 여러 작업이 동시에 시작하여 작업될 수 있습니다. . | nodejs는 싱글쓰레드인가요? . 아닙니다. node.js 자체는 여러개의 스레드를 가지지만, 브라우저에 내장된 자바스크립트 엔진이 싱글스레드 방식입니다. node.js는 자바스크립트 엔진인 V8과 libuv 라이브러리로 구성되어 있는데, 비동기 처리가 필요해질 경우 node api를 통해 libuv 라이브러리에 이벤트를 넣어주고 libuv가 해당 이벤트를 큐에 넣어놓고 스택이 비어있는지를 확인하면서 큐에서 스택으로 이벤트를 넘겨줍니다. 이 과정을 이벤트 루프라고 말하고, 이벤트 루프를 통해서 작업 동시성을 구현할 수 있습니다. . | nodejs는 event-driven architecture 인가요? . node.js 는 이벤트리스너에 콜백함수를 등록해놓습니다. 따라서 시스템에서 어떠한 이벤트가 발생했을 때, 해당 이벤트에 대한 콜백함수가 호출되는 방식으로 이벤트를 처리해주기 때문에 event-driven-architecture라고 할 수 있습니다. . | this와 dynamic scoping . | 객체 지향 프로그래밍이란 무엇인가요? . 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 방법을 말합니다. 객체 지향 프로그래밍에는 여러가지 특징이 있습니다. 먼저 데이터와 기능을 한 곳에 묶어서 클로저함수로 감싸주는 은닉화와 이 과정에서 복잡한 과정은 안으로 숨겨지고 간단한 것만 노출되는 추상화가 있습니다. 그리고 부모 클래스로부터 그 특징을 자식 클래스가 상속을 받아서 그대로 사용할 수 있고, 마지막으로 다형성이 있습니다. 같은 형태의 코드지만 내부의 메소드에 따라서 여러가지 형태를 지닐 수 있습니다. . | Prototype Chaining . 기존에 존재하는 객체를 기반으로 새로운 객체를 생성하는 것을 말합니다. 객체의 프로퍼티에 접근하였을 때, 해당 프로퍼티가 없다면 proto라는 접근자 프로퍼티를 통해서 부모 역할의 객체를 순차적으로 돌아다니면서 검색하여 해당 프로퍼티가 존재하면 그 프로퍼티를 상속받을 수 있습니다. . | IIFE . 즉시 호출 함수 표현식을 말합니다. 특정 상황에서 데이터를 전역 변수에 담지 않고, 해당 데이터에 side-effect를 방지하기위해서 사용됩니다. . | setTimeout 에서 this는 왜 전역을 가리키는지 설명하세요. . | 스택과 힙의 차이에 대해서 설명하세요. . 자바스크립트에서 메모리를 관리하기 위해 사용하는 자료구조입니다. 힙은 참조형 데이터가 저장되고, 스택은 원시타입의 데이터가 저장됩니다. . | call-by-value에 대해서 설명하세요. . 함수의 호출 방식을 말합니다. 함수의 인자로 어떠한 변수의 값을 사용할 떄, 해당 변수의 값은 복사된 값으로 전달되고, 함수 내부에서는 해당 값의 변화가 일어나지만, 변수의 원래의 값에는 변화가 일어나지 않습니다. . |",
            "url": "https://khakisage.github.io/khakisage_blog/javascript/css/2022/09/05/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_3.html",
            "relUrl": "/javascript/css/2022/09/05/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_3.html",
            "date": " • Sep 5, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "면접질문_2",
            "content": "React . 개념과 장점, 그리고 컴포넌트란 무엇인가요? . 리액트는 주로 SPA를 만들때 사용되는, 사용자 인터페이스를 구축하기 위한 자바스크립트 라이브러리를 말합니다. . 리액트의 장점으로는 우선, virtual DOM을 사용합니다. virtual DOM을 사용하여, 브라우저가 렌더링 될때 일어나는 리플로우와 리페인트의 연산을 최소화하여 웹페이지의 성능을 최적화 할 수 있습니다. 둘째로, 컴포넌트의 가독성이 높고 간단하여 유지보수 및 재사용이 용이합니다. 또한, 리액트는 라이브러리이기 때문에 다른 프레임워크와 혼용이 가능하다는 장점이 있습니다. . 컴포넌트란 소프트웨어에서 독립적인 기능을 수행하는 일종의 모듈을 말합니다. 휴대폰이나 컴퓨터와 같은 하드웨어와 같이 이러한 컴포넌트들을 조립하여 소프트웨어를 개발할 수 있습니다. . | 리액트의 내부 작동 원리를 재조정 (Reconciliation) 개념과 함께 설명하세요. . 리액트에서는 브라우저를 렌더링 할 때, 실제 DOM과 동일한 가상의 DOM을 메모리에 만들어서 DOM 조작이 발생했을 때, 가상 돔에서 모든 연산을 수행합니다. 그리고 실제 DOM과 비교하는 작업인 Reconcilaition을 통해 실제 DOM을 갱신시켜서 그 결과를 반영하여 렌더링합니다. . | 리액트에 있는 라이프사이클과 각 라이프사이클의 역할을 설명하세요. . React의 라이프 사이클은 크게 3가지 유형으로 구분됩니다. 첫번째는 DOM이 생성되고 웹 브라우저 상에서 나타나는 단계인 Mount입니다. 두번째는 props나 state가 바뀔때, 부모 컴포넌트가 리렌더링 될때, 혹은 강제로 업데이트될때 나타나는 단계인 Update 입니다. 마지막 단계는 DOM에서 제거되는 단계인 Unmount 입니다. . | Class Component의 생명주기 메소드에 대해서 설명하세요. . mount, update, unmount에 따라 3종류로 나뉘어집니다. . 먼저 컴포넌트가 mount될 때, 컴포넌트를 만들기 위해 사용되는 constructor, props의 값을 state에 동기화 시킬 때 사용되는 getDerivedStateFromProps(), UI를 렌더링하는 render(), 그리고 컴포넌트가 첫 렌더링을 마치고 호출되는 componentDidMount() 메서드가 있습니다. . 다음으로는 컴포넌트가 업데이트 즉, props나 state가 변경될 때 사용되는 메서드들이 있습니다. props의 변화에 따라 state값에 변화를 주고 싶을 때 사용하는 getDerivedStateProps(), 그리고 이에 따라 props나 state의 값이 변경되었을 때 렌더링 여부를 물어보는 shouldComponentUpdate()메소드, 렌더링 하기로 결정되었다면 이를 리렌더링 해주는 render() 메소드, 컴포넌트의 변화를 DOM에 반영하기 직전에 호출하는 getSnapshotBeforeUpdate(), 최종적으로 컴포넌트의 업데이트가 끝난 후 호출되는 componentDidUpdate()메소드가 있습니다. . 마지막으로 컴포넌트가 unmount될 때, 컴포넌트를 DOM에서 제거할 때 호출되는 componentWillUnmount()메소드가 있습니다. . | 리액트 라우터같은 Client Side Routing 에 대해서 설명하세요. . 주소에 따라서 다른 화면이 보여지는 것을 라우팅이라고 하는데, 리액트의 경우 client side routing을 합니다. 이 말은 화면의 전환 및 주소 값의 변경이 서버가 아닌 클라이언트 측에서 일어난다는 뜻입니다. client side routing을 통해서 클라이언트와 서버간의 데이터 트래픽이 감소시킬 수 있고, 보다 자연스러운 페이지 이동을 통해서 사용자 경험에도 이점이 있습니다. 하지만, 검색엔진 최적화에 불리하고, 사용자의 정보를 클라이언트 기반의 쿠키에 저장하기때문에, 보안에 취약하다는 단점이 있습니다. . | state를 직접 변경하지 않고 setState를 사용하는 이유에 대해서 설명하세요. . 리액트를 구성하는 컴포넌트의 라이프 사이클을 고려했을 때, state가 변경되면 일련의 과정을 통해 render()메소드가 실행되어 브라우저의 리렌더링이 일어납니다. 하지만, state를 직접 변경하게 되면 render()메소드를 호출하지 않아서 상태가 변경되었더라도 렌더링이 일어나지 않을 수 있기 때문에 setState와 같은 상태변경함수를 사용합니다. . | Props Drilling 이란 무엇인가요? . Props Drilling 이란 단순하게 말하자면 props를 하위컴포넌트로 전달하는 목적의 컴포넌트를 사용해서 props를 전달하는 과정을 말합니다. props drilling 에서 props가 통과하는 컴포넌트의 갯수가 늘어날수록 코드가 복잡해지고 props를 추적하기도 어려워집니다. 이를 해결하기 위해 주로, 리덕스나 리코일과 같은 상태관리 라이브러리를 사용합니다. . | 리액트 Hooks의 장점은 무엇인가요? . 클래스형 컴포넌트에서는 라이프사이클을 이용하기 위해서 컴포넌트의 마운트, 업데이트, 언마운트를 각기 다른 메소드로 처리하지만, 리액트에서는 useEffect라는 메소드로 모두 처리할 수 있어서 코드가 간결해지고, 가독성이 좋아지는 장점이 있습니다. . | Class Component와 Function Component의 차이점에 대해서 설명하세요. . | virtual DOM이 무엇인가요? virtual DOM이 좋은 이유에 대해서 설명하세요. . 일반적으로 브라우저가 렌더링 될 때, HTML이 파싱되어 DOM 노드 트리를 구성하고, CSS 파일을 파싱하여 CSSOM도 생성됩니다. 이렇게 렌더 트리가 완성되면 레이아웃 및 페인팅 과정을 통해서 렌더링이 되는데, 이때 HTML 파일에 30개의 변화가 생긴다면, 위의 과정이 30번 일어나게 됩니다. 하지만, virtual DOM의 경우 그 변화를 가상돔에 적용을 완료한 후에 그 결과를 실제 DOM에 전달하기 때문에 렌더링은 단 한번만 일어나게 되어 성능적으로 유리합니다. . | JSX가 무엇인가요? . javascript의 확장된 문법으로 자바스크립트에 xml이라는 html과 아주 유사한 문자기반의 마크업 언어가 추가된 언어를 말합니다. . | 웹 성능 향상을 위해 최적화를 해 본 경험이 있나요? 혹은 useMemo와 useCallback 메소드를 활용해 최적화하는 원리에 대해서 설명하세요. . 기억을 하는 메소드라고 생각할 수 있습니다. . | React 에서 상태 변화가 생겼을 때, 변화를 어떻게 알아채는지에 대해서 설명하세요. . 리액트에서는 상태를 immutable하게 관리하기 때문에, 상태의 변화가 일어나면 메모리 내부의 값이 변경되는 것이 아니라 새로운 주소를 생성하여 상태를 변경해주기 때문에, 주소값의 변화로 상태의 변화를 파악할 수 있습니다. . | 여러가지 상태 관리 라이브러리(Apollo, Redux, MobX 등)의 차이점에 대해서 설명하세요. . | useEffect 메소드로 componentWillUnmount 가 동작할 수 있는 방법에 대해서 설명하세요. . |",
            "url": "https://khakisage.github.io/khakisage_blog/react/2022/08/29/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_2.html",
            "relUrl": "/react/2022/08/29/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_2.html",
            "date": " • Aug 29, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "DOM (Document Object Model)",
            "content": "DOM . Document Object Model의 약자로, 웹페이지를 구성하는 HTML element를 JS의 객체처럼 조작할 수 있는 구조를 말한다. . DOM Method . DOM에는 여러 메소드가 있지만, 다른 언어와 마찬가지로 가장 기초적인 CRUD가 존재하며, 추가적으로 적용하는 메소드가 따로 존재한다. . 1. Create . createElement 새로운 element를 변수에 할당할 때, 사용된다. 이때, 주의해야할 점은 아직 DOM의 Tree에 속하지 않았다는 점이다. // 사용 예시 let newDiv = document.createElement(&#39;div&#39;); // newDiv라는 변수에 새로운 div tag를 할당한다. . | . 2. Append . createElement로 생성된 새로운 element를 DOM Tree에 연결해주는 메소드이다. . append Node Object와 DOM string을 연결해줄 수 있고, 한번에 여러가지의 자식요소의 설정이 가능하다. // append let newDiv = document.createElement(&#39;div&#39;); let divChild = document.createElement(&#39;p&#39;); newDiv.append(divChild); divChild.append(&#39;hello world&#39;) // 결과 &lt;div&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt; // 다른 방법 let newDiv = document.createElement(&#39;div&#39;); let divChild = document.createElement(&#39;p&#39;); newDiv.append(divChild, &#39;hello world&#39;); // 결과 &lt;div&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt; . | appendChild append와 달리 Node Object만 연결해줄 수 있으며, Dom string은 연결해줄 수 없고, 한번에 하나의 자식요소만 설정된다. // appendChild let newDiv = document.createElement(&#39;div&#39;); let divChild = document.createElement(&#39;p&#39;); newDiv.appendChild(divChild); // 결과 &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; . 3. Read . 자바스크립트의 경우 값을 조회하기 위해 변수명이나 index, key 값을 사용하지만 DOM의 경우에는 다른 방법을 사용한다. . | querySelector 첫번째 인자에 HTML tag, id, class 를 전달하여 값을 조회할 수 있다. HTML element 중에서 인자로 전달해준 것과 일치되는 것들 중에서 첫번째의 값을 조회한다. | querySelectorAll querySelector과 다르게 전달된 인자와 일치하는 모든 element를 조회한다. 또한 이렇게 조회된 HTML element들은 배열과 유사한 형태로 전달된다. 이것을 Array-like-Object 즉, 유사 배열 혹은 배열형 객체라고 부른다. Array-like-Object는 배열과 같이 for문의 사용이 가능하다. 4. Update . createElement로 생성한 HTML element에 여러 메소드를 사용해서 문자열을 입력하거나 class값을 부여하여 css파일과 연결해줄 수 있다. . | textContent // textContent let newDiv = document.createElement(&#39;div&#39;); newDiv.textContent = &#39;hello world&#39;; // 결과 &lt;div&gt;hello world&lt;/div&gt; . | classList.add // classList.add let newDiv = document.createElement(&#39;div&#39;); newDiv.classList.add(&#39;sth-class&#39;) . 5. Delete . | remove 삭제하려는 element의 위치를 알고 있을 때 사용하는 메소드이다. // remove const container = document.querySelector(&#39;#container&#39;) let newDiv = document.createElement(&#39;div&#39;); container.append(newDiv) newDiv.remove() // container에 append 한 newDiv를 삭제할 수 있다. . | innerHTML = ‘’ 해당 id나 class를 가지는 모든 elementfmf 지울때 사용한다. document.querySelector(&#39;#container&#39;).innerHTML = &#39;&#39;; . | removeChild 자식 element를 지정해서 삭제할 때 사용하는 메소드인데, remove의 경우에는 노드 자체를 메모리에서도 삭제하는 반면, removeChild의 경우 부모 노드와의 관계를 끊어서 DOM Tree와 분리시키는 메소드이다. | .",
            "url": "https://khakisage.github.io/khakisage_blog/dom/javascript/2022/08/23/DOM.html",
            "relUrl": "/dom/javascript/2022/08/23/DOM.html",
            "date": " • Aug 23, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "면접질문_1",
            "content": "HTML . &lt;script&gt;&lt;script async&gt;&lt;script defer&gt; tag에 대해 설명하시오. . 기본적으로 렌더링 과정에서 브라우저는 html 문서를 파싱하다가 &lt;script&gt; tag를 만나면 파싱을 중단하고, 스크립트를 다운로드 -&gt; 파싱 -&gt; 실행 후에 다시 html 문서를 파싱합니다. 렌더링 과정에서 &lt;script async&gt; tag 와 &lt;script defer&gt; tag의 경우 html 문서의 파싱이 중단되지 않고 비동기적으로 스크립트를 다운로드합니다. 다만, &lt;script async&gt; tag의 경우 스크립트의 다운로드가 완료되면 즉시 스크립트가 실행되고 이 순간에는 html 파싱이 정지되고 실행이 완료된 후에 파싱이 진행됩니다. 이때, 스크립트의 실행순서는 코드작성 순서와 무관하게 먼저 다운로드가 완료된 스크립트가 실행됩니다. &lt;script defer&gt; tag의 경우 스크립트의 다운로드가 완료되더라도 html 문서의 파싱이 완료된 후에 스크립트가 실행됩니다. &lt;script async&gt; tag와는 달리 스크립트의 실행 순서를 코드의 작성 순서를 따릅니다. . | 시맨틱 태그에 대해 설명하시오. . 시맨틱 태그는 그 목적과 의미가 분명한 태그를 말합니다. 자주 사용되는 &lt;div&gt;, &lt;span&gt; 태그의 경우 태그 자체만으로는 목적을 알 수 없지만, &lt;form&gt;, &lt;article&gt;, &lt;table&gt; 태그 등은 태그 자체만으로도 그 목적과 의미를 알 수 있습니다. 따라서, SEO를 목적으로 한다면 시맨틱 태그가 중요한 지표로 활용될 수 있고, 이외에도 시각장애인을 위한 화면판독기도 시맨틱 태그를 지표로 사용하기 때문에, 여러 이점이 있습니다. . | DOM . 웹팩과 바벨의 역할에 대해서 설명하세요. | event.preventDefault() 의 역할이 무엇인지 설명하세요. | window.requestAnimationFrame(callback) 의 역할이 무엇인지 설명하세요. | intersection Observer API가 무엇인지 설명하세요. | performance API가 무엇인지 설명하세요. | Bundling이 무엇이며 왜 필요한가요? | 이벤트 위임이 무엇인가요? | 이벤트 버블링이란 무엇이며 막을 수 있는 방법은 무엇인가요? | Javascript . 스코프에 대해서 설명하세요. | 클로져에 대해서 설명하세요. | 클로져의 사용 예제를 알려주세요. | 변수 선언, 초기화, 할당의 차이점에 대해서 설명하세요. | 호이스팅과 Temporal Dead Zone이 어떻게 연관되어있는지 설명하세요. | ES6의 주요 변화점에 대해서 설명하세요. | 원시 자료형, 참조 자료형 | == vs === | 자바스크립트에서 배열의 타입 | undefined와 null 그리고 undeclared의 차이 | rest parameters와 spread syntax | 깊은 복사와 얕은 복사의 차이에 대해서 설명하세요. 자바스크립트에서 깊은 복사를 하는 방법은 무엇인가요? | let, const, var의 차이와 각각의 사용 방법을 설명하세요. | 순수함수란 무엇인가요? |",
            "url": "https://khakisage.github.io/khakisage_blog/html/dom/javascript/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8/2022/08/22/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_1.html",
            "relUrl": "/html/dom/javascript/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8/2022/08/22/%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8_1.html",
            "date": " • Aug 22, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "타입스크립트_1",
            "content": "타입스크립트란? . 자바스크립트에 ‘타입’을 적용한 언어로, 자바스크립트의 확장된 개념이라고 할 수 있다. 타입스크립트는 자바스크립트와 비교하여 두가지 강점을 가진다. . 에러 방지 | 자동 완성 | . example . function sum(a, b) { return a + b; } sum(20, 30); // 50 sum(20, &quot;30&quot;); // 2030 let result = sum(20, 30); result.toLocaleString(); . 자바스크립트의 경우, sum 함수를 작성하였을 때, 함수의 인자에 숫자가 아닌 문자열이 들어와도 일단 작동은 된다. 다만, 자동으로 문자열로 인식되므로, “2030”으로 출력된다. . function sum(a: number, b: number): number { return a + b; } sum(20, 30); // 50 sum(10, &quot;20&quot;); // &quot;20&quot;은 문자열이므로 b 에 할당될 수 없다는 에러가 발생한다. let result = sum(20, 30); result.toLocaleString(); . 타입스크립트의 경우, sum 함수 작성 단계에서 함수의 인자들의 타입을 미리 정해주었기 때문에, 인자에 문자열이 들어오게 되면, 에러가 발생한다. . 첫째로, 자바스크립트의 경우에는 에디터 상에서 잘못된 점을 발견할 수 없고, 브라우저의 콘솔창에서 확인이 가능하다. 하지만, 타입스크립트의 경우에는 에디터 상에서 오탈자나 잘못된 타입의 인자가 들어온다면 에러가 발생했다는 표시가 나와 에러를 사전에 방지할 수 있다는 장점이 있다. . 둘째로, 자바스크립트의 경우 sum 함수의 결과를 result에 할당하였을 때, result에서 toLocaleString()라는 메서드를 작성 시, 자동완성이 나오지 않으며 직접 다 작성을 해주어야 한다. (이 과정에서, 오류가 발생할지는 미지수이다.) 하지만, 타입스크립트의 경우에는 자바스크립트와 동일하게 작성 시, toLo까지만 입력해도 자동완성되는 메서드가 표시된다. (이 과정에서, 오류가 발생할 확률은 자바스크립트보다 현저히 낮다.) . JSDoc &amp; @ts-check . 앞서 설명한 타입스크립트로 작성을 하지 않더라도, 자바스크립트 환경에서 ‘JSDoc’과 ‘@ts-check’를 이용해서 타입스크립트와 유사한 기능을 사용할 수 있다. . ###JSDoc이란? 공식문서에 따르면, JavaScript 용 API 문서 생성기라고 한다. 다시 말하자면, 흔히 API 문서를 메뉴판에 비유하는 것처럼 JS파일에서 작성되는 모듈, 메서드, 매개변수 등에 보다 자세한 사용방법을 첨부하여, 해당 JS파일에서 ‘이 모듈은 어떻게 사용하셔야 하고, 이 메서드에 인자에는 숫자만 혹은 문자열만 넣어주셔야 오류가 발생하지 않습니다’ 라고 설명해주는 용도로 생각된다. 기본적인 사용방법은 . /** * @생성자 를 넣어서 아래의 코드에 대한 사용 방법을 첨부한다. 생성자는 공식문서에 보다 자세하게 나와있다. */ . 위에서 예시로 든 sum 함수를 ‘JSDoc’과 ‘@ts-check’를 사용하여 다시 작성한다면 다음과 같다. . //@ts-check /** * @param {number} a 첫번째 숫자 * @param {number} b 두번째 숫자 */ function sum(a, b) { return a + b; } sum(10, &quot;20&quot;); // 타입스크립트와 마찬가지로 에디터 상에서 오류 표시를 확인할 수 있다. . VSCode 상에서 함수와 오류는 다음과 같이 표시된다. . 결론 . JS파일에서도 ‘JSDoc’ 과 ‘@ts-check’의 조합으로, JS 환경에서도 타입스크립트와 비슷한 느낌(?)으로 사용할 수 있었다. 하지만, 위의 환경으로 작성하는 것보다, 타입스크립트 환경에서 작성하는 것이 보다 덜 힘들게 작성할 수 있고, 보기에도 더 깔끔해보인다. 물론, 내가 만들었던 프로젝트를 TS로 리팩토링하는 과정에서 많은 어려움이 있겠지만 이 시간들이 나에게 큰 도움이 될 것이라고 믿는다. . Stay Focused! .",
            "url": "https://khakisage.github.io/khakisage_blog/typescript/javascript/jsdoc/2022/07/13/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_1.html",
            "relUrl": "/typescript/javascript/jsdoc/2022/07/13/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_1.html",
            "date": " • Jul 13, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "마크다운 포스팅",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://khakisage.github.io/khakisage_blog/markdown/2022/07/12/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4_%ED%85%8C%EC%8A%A4%ED%8A%B8.html",
            "relUrl": "/markdown/2022/07/12/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4_%ED%85%8C%EC%8A%A4%ED%8A%B8.html",
            "date": " • Jul 12, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://khakisage.github.io/khakisage_blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://khakisage.github.io/khakisage_blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "“Stay Focused!” . 개발 이전의 나 . 이리저리 방향을 못잡고, 방황했어요. 매번 새로움을 찾는다고 말하면서, 정작 같은 공부만 10년 정도를 했네요. 처음 4년은 성적에 맞춰 대학을 가서, 식품공학을 공부했어요. 이후, 다시 3년 정도를 더 나은 대학을 가서, 역시 식품공학을 공부했어요. 같은 전공으로 대학원에 진학도 했었어요. 졸업을 한학기 남겨두고, 떠나왔지만 후회는 없어요. . 개발 이후의 나 . 아이디어가 샘솟지는 않지만, 내가 아쉽다고 생각한 것들을 개선할 수 있다는 점에 관심이 생겼어요. 공대를 다녔던 것도 아니었고, 컴퓨터는 게임이나 문서작업 용도로만 썼었고, 터미널 창은 가끔 아이피 주소 확인을 위해서만 열었어요. 처음에는 터미널 창을 열고 명령어만 눌러도 마치 내가 프로그래머가 된 것 마냥 신기하고 그 자체가 멋있었어요. 코딩을 해야겠다고 생각하고, 파이썬으로 입문을 했었는데, 사실 이걸로 그래서 뭘 하는 거지 하는 생각이 있었어요. 웹 개발을 공부하면서, 20년동안 사용해왔던 인터넷이 어떻게 만들어지고, 실행되는지 알게됐는데, 아무것도 모르고 사용했던 과거의 제가 부끄럽네요. 자바스크립트를 기반으로 리액트를 사용하여 웹 페이지를 만들어보았어요. 아직도, 코드를 작성할 때, 구글링을 많이 하고, 매번 수많은 오류에 부딪히지만, 문제들을 해결해가면서 느끼는 성취감이 너무 좋아요. .",
          "url": "https://khakisage.github.io/khakisage_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://khakisage.github.io/khakisage_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}